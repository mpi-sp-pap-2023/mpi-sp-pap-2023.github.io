<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>IndPrinciples: Induction Principles</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="common/slides.js"></script>
<link href="common/css/slides.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 1: Logical Foundations</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
   <li class='section_name'><a href='deps.html'>Roadmap</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">IndPrinciples<span class="subtitle">Induction Principles</span></h1>


<div class="doc">

<div class="paragraph"> </div>

 Let's take a deeper look at induction. 
</div>

<div class="doc">
<a id="lab360"></a><h1 class="section">Basics</h1>

<div class="paragraph"> </div>

 The automatically generated <i>induction principle</i> for <span class="inlinecode"><span class="id" title="var">nat</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Check</span> <span class="id" title="var">nat_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> 0 →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> → <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
In English: Suppose <span class="inlinecode"><span class="id" title="var">P</span></span> is a property of natural numbers (that is,
      <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> is a <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> for every <span class="inlinecode"><span class="id" title="var">n</span></span>). To show that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> holds of all
      <span class="inlinecode"><span class="id" title="var">n</span></span>, it suffices to show:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode">0</span>

</li>
<li> for any <span class="inlinecode"><span class="id" title="var">n</span></span>, if <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode"><span class="id" title="var">n</span></span>, then <span class="inlinecode"><span class="id" title="var">P</span></span> holds of <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab361"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 We can directly use the induction principle with <span class="inlinecode"><span class="id" title="tactic">apply</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mul_0_r'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>:<span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">n</span> × 0 = 0.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">nat_ind</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;O&nbsp;*)</span> <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n&nbsp;=&nbsp;S&nbsp;n'&nbsp;*)</span> <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">n'</span> <span class="id" title="var">IHn'</span>. <span class="id" title="tactic">rewrite</span> → <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Why the <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic is nicer than <span class="inlinecode"><span class="id" title="tactic">apply</span></span>:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="tactic">apply</span></span> requires extra manual bookkeeping (the <span class="inlinecode"><span class="id" title="tactic">intros</span></span> in the
       inductive case)

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">apply</span></span> requires <span class="inlinecode"><span class="id" title="var">n</span></span> to be left universally quantified

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">apply</span></span> requires us to manually specify the name of the induction
       principle. 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab362"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

<a id="lab363"></a><h3 class="section"> </h3>
 Coq generates induction principles for every datatype defined with
    <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>, including those that aren't recursive. 
<div class="paragraph"> </div>

 If we define type <span class="inlinecode"><span class="id" title="var">t</span></span> with constructors <span class="inlinecode"><span class="id" title="var">c<sub>1</sub></span></span> ... <span class="inlinecode"><span class="id" title="var">cn</span></span>,
    Coq generates:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">t_ind</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="var">t</span> → <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <span class="id" title="tactic">case</span> <span class="id" title="keyword">for</span> <span class="id" title="var">c<sub>1</sub></span> ... →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <span class="id" title="tactic">case</span> <span class="id" title="keyword">for</span> <span class="id" title="var">c<sub>2</sub></span> ... → ...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... <span class="id" title="tactic">case</span> <span class="id" title="keyword">for</span> <span class="id" title="var">cn</span> ... →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">t</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span>
</span>    The specific shape of each case depends on the arguments to the
    corresponding constructor. 
<div class="paragraph"> </div>

<a id="lab364"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 An example with no constructor arguments: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">time</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">day</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">night</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">time_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="var">time</span> → <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">day</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">night</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> : <span class="id" title="var">time</span>, <span class="id" title="var">P</span> <span class="id" title="var">t</span>.<br/>
</div>

<div class="doc">
<a id="lab365"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

<a id="lab366"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 An example with constructor arguments: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">natlist</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">nnil</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">ncons</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">natlist_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="var">natlist</span> → <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">nnil</span>  →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">l</span> → <span class="id" title="var">P</span> (<span class="id" title="var">ncons</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span>.<br/>
</div>

<div class="doc">
<a id="lab367"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 In general, the automatically generated induction principle for
    inductive type <span class="inlinecode"><span class="id" title="var">t</span></span> is formed as follows:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Each constructor <span class="inlinecode"><span class="id" title="var">c</span></span> generates one case of the principle.

</li>
<li> If <span class="inlinecode"><span class="id" title="var">c</span></span> takes no arguments, that case is:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"P holds of c"
</span>
</li>
<li> If <span class="inlinecode"><span class="id" title="var">c</span></span> takes arguments <span class="inlinecode"><span class="id" title="var">x<sub>1</sub></span>:<span class="id" title="var">a<sub>1</sub></span></span> ... <span class="inlinecode"><span class="id" title="var">xn</span>:<span class="id" title="var">an</span></span>, that case is:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"For all x<sub>1</sub>:a<sub>1</sub> ... xn:an,
          if [P] holds of each of the arguments of type [t],
          then [P] holds of [c x<sub>1</sub> ... xn]"
</span>      But that oversimplifies a little.  An assumption about <span class="inlinecode"><span class="id" title="var">P</span></span>
      holding of an argument <span class="inlinecode"><span class="id" title="var">x</span></span> of type <span class="inlinecode"><span class="id" title="var">t</span></span> actually occurs
      immediately after the quantification of <span class="inlinecode"><span class="id" title="var">x</span></span>.

</li>
</ul>

<div class="paragraph"> </div>

<a id="lab368"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 For example, suppose we had written the definition of <span class="inlinecode"><span class="id" title="var">natlist</span></span> a little
    differently: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">natlist'</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">nnil'</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">nsnoc</span> (<span class="id" title="var">l</span> : <span class="id" title="var">natlist'</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>).<br/>
</div>

<div class="doc">
Now the induction principle case for <span class="inlinecode"><span class="id" title="var">nsnoc1</span></span> is a bit different
    than the earlier case for <span class="inlinecode"><span class="id" title="var">ncons</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Check</span> <span class="id" title="var">natlist'_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="var">natlist'</span> → <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">nnil'</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">l</span> : <span class="id" title="var">natlist'</span>, <span class="id" title="var">P</span> <span class="id" title="var">l</span> → <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> (<span class="id" title="var">nsnoc</span> <span class="id" title="var">l</span> <span class="id" title="var">n</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">natlist'</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
<a id="lab369"></a><h1 class="section">Induction Principles for Propositions</h1>

<div class="paragraph"> </div>

 Inductive definitions of propositions also cause Coq to generate
    induction priniciples.  For example, recall our proposition <span class="inlinecode"><span class="id" title="var">ev</span></span>
    from <a href="IndProp.html"><span class="inlineref">IndProp</span></a>: 
</div>
<div class="code">

<span class="id" title="keyword">Print</span> <span class="id" title="var">ev</span>.<br/><hr class='doublespaceincode'/>
<span class="comment">(*&nbsp;===&gt;<br/>
<br/>
&nbsp;&nbsp;Inductive&nbsp;ev&nbsp;:&nbsp;nat&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;|&nbsp;ev_0&nbsp;:&nbsp;ev&nbsp;0<br/>
&nbsp;&nbsp;|&nbsp;ev_SS&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;ev&nbsp;n&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;ev&nbsp;(S&nbsp;(S&nbsp;n)))<br/>
<br/>
*)</span><br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">ev_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> 0 →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">P</span> <span class="id" title="var">n</span> → <span class="id" title="var">P</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>))) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">P</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
In English, <span class="inlinecode"><span class="id" title="var">ev_ind</span></span> says: Suppose <span class="inlinecode"><span class="id" title="var">P</span></span> is a property of natural
    numbers.  To show that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> holds whenever <span class="inlinecode"><span class="id" title="var">n</span></span> is even, it suffices
    to show:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">P</span></span> holds for <span class="inlinecode">0</span>,

<div class="paragraph"> </div>


</li>
<li> for any <span class="inlinecode"><span class="id" title="var">n</span></span>, if <span class="inlinecode"><span class="id" title="var">n</span></span> is even and <span class="inlinecode"><span class="id" title="var">P</span></span> holds for <span class="inlinecode"><span class="id" title="var">n</span></span>, then <span class="inlinecode"><span class="id" title="var">P</span></span>
        holds for <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>. 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab370"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

<a id="lab371"></a><h3 class="section"> </h3>
 The precise form of an <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> definition can affect the
    induction principle Coq generates. 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">le<sub>1</sub></span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">le1_n</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">le<sub>1</sub></span> <span class="id" title="var">n</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">le1_S</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, (<span class="id" title="var">le<sub>1</sub></span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) → (<span class="id" title="var">le<sub>1</sub></span> <span class="id" title="var">n</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>)).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> &quot;m &lt;=1 n" := (<span class="id" title="var">le<sub>1</sub></span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70).<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">n</span></span> could instead be a parameter:  
<div class="paragraph"> </div>

<a id="lab372"></a><h3 class="section"> </h3>

</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">le<sub>2</sub></span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">le2_n</span> : <span class="id" title="var">le<sub>2</sub></span> <span class="id" title="var">n</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">le2_S</span> <span class="id" title="var">m</span> (<span class="id" title="var">H</span> : <span class="id" title="var">le<sub>2</sub></span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) : <span class="id" title="var">le<sub>2</sub></span> <span class="id" title="var">n</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> &quot;m &lt;=2 n" := (<span class="id" title="var">le<sub>2</sub></span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70).<br/>
</div>

<div class="doc">
<a id="lab373"></a><h3 class="section"> </h3>

</div>
<div class="code">

<span class="id" title="keyword">Check</span> <span class="id" title="var">le1_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;=1 <span class="id" title="var">m</span> → <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> → <span class="id" title="var">P</span> <span class="id" title="var">n</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">n<sub>0</sub></span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;=1 <span class="id" title="var">n<sub>0</sub></span> → <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="var">n<sub>0</sub></span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">le2_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">n</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;=2 <span class="id" title="var">m</span> → <span class="id" title="var">P</span> <span class="id" title="var">m</span> → <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n<sub>0</sub></span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &lt;=2 <span class="id" title="var">n<sub>0</sub></span> → <span class="id" title="var">P</span> <span class="id" title="var">n<sub>0</sub></span>.<br/>
</div>

<div class="doc">
The latter is simpler, and corresponds to Coq's own
    definition. 
</div>

<div class="doc">
<a id="lab374"></a><h1 class="section">Explicit Proof Objects for Induction (Optional)</h1>

<div class="paragraph"> </div>

 Recall again the induction principle on naturals that Coq generates for
    us automatically from the Inductive declaration for <span class="inlinecode"><span class="id" title="var">nat</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Check</span> <span class="id" title="var">nat_ind</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> 0 →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> → <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
There's nothing magic about this induction lemma: it's just
   another Coq lemma that requires a proof.  Coq generates the proof
   automatically too...  
</div>
<div class="code">

<span class="id" title="keyword">Print</span> <span class="id" title="var">nat_ind</span>.<br/>
</div>

<div class="doc">
We can rewrite that more tidily as follows: 
</div>
<div class="code">
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">build_proof</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">evPO</span> : <span class="id" title="var">P</span> 0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">evPS</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> → <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">P</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| 0 ⇒ <span class="id" title="var">evPO</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">k</span> ⇒ <span class="id" title="var">evPS</span> <span class="id" title="var">k</span> (<span class="id" title="var">build_proof</span> <span class="id" title="var">P</span> <span class="id" title="var">evPO</span> <span class="id" title="var">evPS</span> <span class="id" title="var">k</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">nat_ind_tidy</span> := <span class="id" title="var">build_proof</span>.<br/>
</div>

<div class="doc">
Recursive function <span class="inlinecode"><span class="id" title="var">build_proof</span></span> thus pattern matches against
    <span class="inlinecode"><span class="id" title="var">n</span></span>, recursing all the way down to 0, and building up a proof
    as it returns. 
<div class="paragraph"> </div>

 We can also define <i>non-standard</i> induction principles
   in this style. Recall this troublesome thoerem: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_ev</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>: <span class="id" title="var">nat</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> = <span class="id" title="var">true</span> → <span class="id" title="var">ev</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_0</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>.<br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
Attempts to prove this by standard induction on <span class="inlinecode"><span class="id" title="var">n</span></span> fail in the case for
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>, because the induction hypothesis only tells us something about
    <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, which is useless. There are various ways to hack around this problem;
    for example, we <i>can</i> use ordinary induction on <span class="inlinecode"><span class="id" title="var">n</span></span> to prove this (try it!):

<div class="paragraph"> </div>

    <span class="inlinecode"><span class="id" title="keyword">Lemma</span></span> <span class="inlinecode"><span class="id" title="var">even_ev'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span>
     <span class="inlinecode">(<span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">∧</span> <span class="inlinecode">(<span class="id" title="var">even</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span>.

<div class="paragraph"> </div>

    But we can make a much better proof by defining and proving a
    non-standard induction principle that goes "by twos":
 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">nat_ind2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> 0 →<br/>
&nbsp;&nbsp;<span class="id" title="var">P</span> 1 →<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> → <span class="id" title="var">P</span> (<span class="id" title="var">S</span>(<span class="id" title="var">S</span> <span class="id" title="var">n</span>))) →<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span> , <span class="id" title="var">P</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">P</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">P<sub>0</sub></span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">P<sub>1</sub></span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">PSS</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span>:<span class="id" title="var">nat</span>) := <span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 ⇒ <span class="id" title="var">P<sub>0</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1 ⇒ <span class="id" title="var">P<sub>1</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) ⇒ <span class="id" title="var">PSS</span> <span class="id" title="var">n'</span> (<span class="id" title="var">f</span> <span class="id" title="var">n'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
Once you get the hang of it, it is entirely straightforward to
     give an explicit proof term for induction principles like this.
     Proving this as a lemma using tactics is much less intuitive.

<div class="paragraph"> </div>

     The <span class="inlinecode"><span class="id" title="tactic">induction</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="keyword">using</span></span> tactic variant gives a convenient way to
     utilize a non-standard induction principle like this. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">even_ev</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">even</span> <span class="id" title="var">n</span> = <span class="id" title="var">true</span> → <span class="id" title="var">ev</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [ | |<span class="id" title="var">n'</span>] <span class="id" title="keyword">using</span> <span class="id" title="var">nat_ind2</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_0</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab375"></a><h4 class="section">Exercise: 4 stars, standard, optional (t_tree)</h4>
 What if we wanted to define binary trees as follows, using a
    constructor that bundles the children and value at a node into a
    tuple? 
</div>
<div class="code">

<span class="id" title="keyword">Notation</span> &quot;( x , y , .. , z )" := (<span class="id" title="var">pair</span> .. (<span class="id" title="var">pair</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) .. <span class="id" title="var">z</span>) : <span class="id" title="var">core_scope</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">t_tree</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">t_leaf</span><br/>
| <span class="id" title="var">t_branch</span> : (<span class="id" title="var">t_tree</span> <span class="id" title="var">X</span> × <span class="id" title="var">X</span> × <span class="id" title="var">t_tree</span> <span class="id" title="var">X</span>) → <span class="id" title="var">t_tree</span> <span class="id" title="var">X</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">t_leaf</span> {<span class="id" title="var">X</span>}.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">t_branch</span> {<span class="id" title="var">X</span>}.<br/>
</div>

<div class="doc">
Unfortunately, the automatically-generated induction principle is
    not as strong as we need. It doesn't introduce induction hypotheses
    for the subtrees. 
</div>
<div class="code">

<span class="id" title="keyword">Check</span> <span class="id" title="var">t_tree_ind</span>.<br/>
</div>

<div class="doc">
That will get us in trouble if we want to prove something by
    induction, such as that <span class="inlinecode"><span class="id" title="var">reflect</span></span> is an involution. 
</div>
<div class="code">

<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">reflect</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">t</span> : <span class="id" title="var">t_tree</span> <span class="id" title="var">X</span>) : <span class="id" title="var">t_tree</span> <span class="id" title="var">X</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">t</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">t_leaf</span> ⇒ <span class="id" title="var">t_leaf</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">t_branch</span> (<span class="id" title="var">l</span>, <span class="id" title="var">v</span>, <span class="id" title="var">r</span>) ⇒ <span class="id" title="var">t_branch</span> (<span class="id" title="var">reflect</span> <span class="id" title="var">r</span>, <span class="id" title="var">v</span>, <span class="id" title="var">reflect</span> <span class="id" title="var">l</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">reflect_involution</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">t_tree</span> <span class="id" title="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reflect</span> (<span class="id" title="var">reflect</span> <span class="id" title="var">t</span>) = <span class="id" title="var">t</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">X</span> <span class="id" title="var">t</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">t</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span> <span class="id" title="keyword">as</span> [[<span class="id" title="var">l</span> <span class="id" title="var">v</span>] <span class="id" title="var">r</span>]. <span class="id" title="tactic">simpl</span>. <span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
We get stuck, because we have no inductive hypothesis for <span class="inlinecode"><span class="id" title="var">l</span></span> or
    <span class="inlinecode"><span class="id" title="var">r</span></span>. So, we need to define our own custom induction principle, and
    use it to complete the proof.

<div class="paragraph"> </div>

    First, define the type of the induction principle that you want to
    use. There are many possible answers. Recall that you can use
    <span class="inlinecode"><span class="id" title="keyword">match</span></span> as part of the definition. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">better_t_tree_ind_type</span> : <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;REPLACE&nbsp;THIS&nbsp;LINE&nbsp;WITH&nbsp;":=&nbsp;_your_definition_&nbsp;."&nbsp;*)</span>. <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
Second, define the induction principle by giving a term of that
    type. Use the examples about <span class="inlinecode"><span class="id" title="var">nat</span></span>, above, as models. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">better_t_tree_ind</span> : <span class="id" title="var">better_t_tree_ind_type</span><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;REPLACE&nbsp;THIS&nbsp;LINE&nbsp;WITH&nbsp;":=&nbsp;_your_definition_&nbsp;."&nbsp;*)</span>. <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
Finally, prove the theorem. If <span class="inlinecode"><span class="id" title="tactic">induction</span>...<span class="id" title="keyword">using</span></span> gives you an
    error about "Cannot recognize an induction scheme", don't worry
    about it. The <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic is picky about the shape of the
    theorem you pass to it, but it doesn't give you much information
    to debug what is wrong about that shape.  You can use <span class="inlinecode"><span class="id" title="tactic">apply</span></span>
    instead, as we saw at the beginning of this file. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">reflect_involution</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">t</span> : <span class="id" title="var">t_tree</span> <span class="id" title="var">X</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reflect</span> (<span class="id" title="var">reflect</span> <span class="id" title="var">t</span>) = <span class="id" title="var">t</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>