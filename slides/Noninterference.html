<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>Noninterference: Defining Secrecy and Secure Multi-Execution</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="common/slides.js"></script>
<link href="common/css/slides.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 1: Logical Foundations</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
   <li class='section_name'><a href='deps.html'>Roadmap</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">Noninterference<span class="subtitle">Defining Secrecy and Secure Multi-Execution</span></h1>


<div class="doc">

<div class="paragraph"> </div>

 Information flow control tries to prevent the leak of secret information to
    public outputs.

<div class="paragraph"> </div>

    But how does one formalize that a program doesn't leak secret information?

<div class="paragraph"> </div>

    We first investigate this question in the very simple setting of Coq
    functions taking two arguments, one we call the public input and the other
    one we call the secret input. Our functions return a pair containing one
    public output and one secret output. 
<div class="paragraph"> </div>

 Say we have the following function working on natural numbers: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">secure_f</span> (<span class="id" title="var">pi</span> <span class="id" title="var">si</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span>×<span class="id" title="var">nat</span> := (<span class="id" title="var">pi</span>+1, <span class="id" title="var">pi</span>+<span class="id" title="var">si</span>*2).<br/>
</div>

<div class="doc">
This function seems intuitively secure, since the first output <span class="inlinecode"><span class="id" title="var">pi</span>+1</span>, which
    we assume to be public, only depends on the public input <span class="inlinecode"><span class="id" title="var">pi</span></span>, but not on
    the secret input <span class="inlinecode"><span class="id" title="var">si</span></span>. The second output <span class="inlinecode"><span class="id" title="var">pi</span>+<span class="id" title="var">si</span>*2</span> depends on both the
    public input and the secret input, but that's okay, since we assume this
    second output to be secret. Still, what security notion does this function
    satisfy? Let's try it on a couple of inputs: 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <span class="id" title="var">example1_secure_f</span> : <span class="id" title="var">secure_f</span> 0 0 = (1,0).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">example2_secure_f</span> : <span class="id" title="var">secure_f</span> 0 1 = (1,2).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">example3_secure_f</span> : <span class="id" title="var">secure_f</span> 1 2 = (2,5).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
In the last two cases the value of the public output is equal to the value
    of secret input. But that's just a coincidence, and has nothing to do with
    the public output leaking the secret input, which wasn't used in computing
    the public output.

<div class="paragraph"> </div>

    So a naive security definition, which we'll only use as a strawman, is one
    that simply compares secret inputs with public outputs: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">broken_def</span> (<span class="id" title="var">f</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span>×<span class="id" title="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>, <span class="id" title="var">fst</span> (<span class="id" title="var">f</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>) ≠ <span class="id" title="var">si</span>.<br/>
</div>

<div class="doc">
This definition would reject our secure function above as insecure: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">broken_def_rejects_secure_f</span> : ¬<span class="id" title="var">broken_def</span> <span class="id" title="var">secure_f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">broken_def</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">contra</span> 0 1). <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Even worse, this broken definition of security would allow insecure
    functions, such as the following one whose public output is <span class="inlinecode"><span class="id" title="var">si</span>+1</span>: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">insecure_f</span> (<span class="id" title="var">pi</span> <span class="id" title="var">si</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span>×<span class="id" title="var">nat</span> := (<span class="id" title="var">si</span>+1, <span class="id" title="var">pi</span>+<span class="id" title="var">si</span>*2).<br/>
</div>

<div class="doc">
This function's public output is never equal to its secret input, yet an
    attacker can easily compute one from the other by just subtracting <span class="inlinecode">1</span>. So
    the secret is entirely leaked, yet our broken definition accepts this: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">broken_def_accepts_insecure_f</span> : <span class="id" title="var">broken_def</span> <span class="id" title="var">insecure_f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">broken_def</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">si</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">si'</span> <span class="id" title="var">IH</span>].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">contra</span>. <span class="id" title="tactic">discriminate</span> <span class="id" title="var">contra</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> ×. <span class="id" title="tactic">intro</span> <span class="id" title="var">Hc</span>. <span class="id" title="tactic">injection</span> <span class="id" title="var">Hc</span> <span class="id" title="keyword">as</span> <span class="id" title="var">Hc</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IH</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">Hc</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
This attempt at defining secure information flow by looking at how inputs
    and outputs are related for a single execution of the program has failed.
    In fact, it is well known in the formal security research community that
    secure information flow cannot be defined by looking at just one single
    program execution. 
<div class="paragraph"> </div>

<a id="lab443"></a><h2 class="section">Noninterference for pure functions</h2>

<div class="paragraph"> </div>

 The usual way to define secure information flow is a property called
    <i>noninterference</i>, which in its most standard form looks at <i>two</i> program
    executions: for two different secret inputs the public outputs should not
    change: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">noninterferent</span> {<span class="id" title="var">PI</span> <span class="id" title="var">SI</span> <span class="id" title="var">PO</span> <span class="id" title="var">SO</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">PI</span> → <span class="id" title="var">SI</span> → <span class="id" title="var">PO</span>×<span class="id" title="var">SO</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">pi</span>:<span class="id" title="var">PI</span>) (<span class="id" title="var">si<sub>1</sub></span> <span class="id" title="var">si<sub>2</sub></span>:<span class="id" title="var">SI</span>), <span class="id" title="var">fst</span> (<span class="id" title="var">f</span> <span class="id" title="var">pi</span> <span class="id" title="var">si<sub>1</sub></span>) = <span class="id" title="var">fst</span> (<span class="id" title="var">f</span> <span class="id" title="var">pi</span> <span class="id" title="var">si<sub>2</sub></span>).<br/>
</div>

<div class="doc">
We defined this for arbitrary types of inputs and outputs, but we can still
    instantiate them to <span class="inlinecode"><span class="id" title="var">nat</span></span> when looking at our example functions above: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">noninterferent_secure_f</span> : <span class="id" title="var">noninterferent</span> <span class="id" title="var">secure_f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent</span>, <span class="id" title="var">secure_f</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">interferent_insecure_f</span> : ¬<span class="id" title="var">noninterferent</span> <span class="id" title="var">insecure_f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent</span>, <span class="id" title="var">insecure_f</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">contra</span> 0 0 1). <span class="id" title="tactic">discriminate</span> <span class="id" title="var">contra</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="tactic">specialize</span></span> we used above instantiates a quantified hypothesis to
    the concrete arguments we specify. 
<div class="paragraph"> </div>

 In the definition of noninterference we pass the same public inputs to the
    two executions, since this allows public outputs to depend on public
    inputs. To convince ourselves of this, let's look at the following too
    strong definition of security: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">too_strong_def</span> {<span class="id" title="var">PI</span> <span class="id" title="var">SI</span> <span class="id" title="var">PO</span> <span class="id" title="var">SO</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">PI</span> → <span class="id" title="var">SI</span> → <span class="id" title="var">PO</span>×<span class="id" title="var">SO</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">pi<sub>1</sub></span> <span class="id" title="var">pi<sub>2</sub></span>:<span class="id" title="var">PI</span>) (<span class="id" title="var">si<sub>1</sub></span> <span class="id" title="var">si<sub>2</sub></span>:<span class="id" title="var">SI</span>), <span class="id" title="var">fst</span> (<span class="id" title="var">f</span> <span class="id" title="var">pi<sub>1</sub></span> <span class="id" title="var">si<sub>1</sub></span>) = <span class="id" title="var">fst</span> (<span class="id" title="var">f</span> <span class="id" title="var">pi<sub>2</sub></span> <span class="id" title="var">si<sub>2</sub></span>).<br/>
</div>

<div class="doc">
This basically says that the first output of <span class="inlinecode"><span class="id" title="var">f</span></span> has to be constant, which
    is not the case for our <span class="inlinecode"><span class="id" title="var">secure_f</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">secure_f_rejected_again</span> : ¬<span class="id" title="var">too_strong_def</span> <span class="id" title="var">secure_f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">too_strong_def</span>, <span class="id" title="var">secure_f</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">contra</span> 0 1 0 0). <span class="id" title="tactic">discriminate</span> <span class="id" title="var">contra</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Noninterference is still a very strong property. In particular, <span class="inlinecode"><span class="id" title="var">f</span></span> being
    noninterferent is equivalent to <span class="inlinecode"><span class="id" title="var">f</span></span> being splittable into two different
    functions, one of which doesn't get the secret at all. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">splittable</span> {<span class="id" title="var">PI</span> <span class="id" title="var">SI</span> <span class="id" title="var">PO</span> <span class="id" title="var">SO</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">PI</span> → <span class="id" title="var">SI</span> → <span class="id" title="var">PO</span>×<span class="id" title="var">SO</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> (<span class="id" title="var">pf</span> : <span class="id" title="var">PI</span> → <span class="id" title="var">PO</span>) (<span class="id" title="var">sf</span>:<span class="id" title="var">PI</span> → <span class="id" title="var">SI</span> → <span class="id" title="var">SO</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span> , <span class="id" title="var">f</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span> = (<span class="id" title="var">pf</span> <span class="id" title="var">pi</span>, <span class="id" title="var">sf</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">splittable_noninterferent</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">PI</span> <span class="id" title="var">SI</span> <span class="id" title="var">PO</span> <span class="id" title="var">SO</span> : <span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">f</span> : <span class="id" title="var">PI</span> → <span class="id" title="var">SI</span> → <span class="id" title="var">PO</span>×<span class="id" title="var">SO</span>, <span class="id" title="var">splittable</span> <span class="id" title="var">f</span> → <span class="id" title="var">noninterferent</span> <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">splittable</span>, <span class="id" title="var">noninterferent</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">PI</span> <span class="id" title="var">SI</span> <span class="id" title="var">PO</span> <span class="id" title="var">SO</span> <span class="id" title="var">f</span> [<span class="id" title="var">pf</span> [<span class="id" title="var">sf</span> <span class="id" title="var">H</span>]] <span class="id" title="var">pi</span> <span class="id" title="var">si<sub>1</sub></span> <span class="id" title="var">si<sub>2</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">noninterferent_splittable</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">PI</span> <span class="id" title="var">SI</span> <span class="id" title="var">PO</span> <span class="id" title="var">SO</span> : <span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">some_si</span> : <span class="id" title="var">SI</span>, <span class="comment">(*&nbsp;we&nbsp;require&nbsp;SI&nbsp;to&nbsp;be&nbsp;an&nbsp;inhabited&nbsp;type!&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">f</span> : <span class="id" title="var">PI</span> → <span class="id" title="var">SI</span> → <span class="id" title="var">PO</span>×<span class="id" title="var">SO</span>, <span class="id" title="var">noninterferent</span> <span class="id" title="var">f</span> → <span class="id" title="var">splittable</span> <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">splittable</span>, <span class="id" title="var">noninterferent</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">PI</span> <span class="id" title="var">SI</span> <span class="id" title="var">PO</span> <span class="id" title="var">SO</span> <span class="id" title="var">some_si</span> <span class="id" title="var">f</span> <span class="id" title="var">Hni</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;we&nbsp;pass&nbsp;the&nbsp;SI&nbsp;inhabitant&nbsp;as&nbsp;a&nbsp;dummy&nbsp;secret&nbsp;value!&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">pi</span> ⇒ <span class="id" title="var">fst</span> (<span class="id" title="var">f</span> <span class="id" title="var">pi</span> <span class="id" title="var">some_si</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span> ⇒ <span class="id" title="var">snd</span> (<span class="id" title="var">f</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>. <span class="id" title="tactic">rewrite</span> (<span class="id" title="var">Hni</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">si</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">po</span> <span class="id" title="var">so</span>]. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab444"></a><h2 class="section">Secure Multi-Execution (SME)</h2>

<div class="paragraph"> </div>

 The previous proof also captures the key idea behind Secure Multi-Execution
    (SME), an enforcement mechanism that can make <i>any</i> function
    noninterferent. To achieve this SME runs the function twice, once passing a
    dummy secret as input to obtain the public output, and once using the real
    secrets to obtain the secret output. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">sme</span> {<span class="id" title="var">PI</span> <span class="id" title="var">SI</span> <span class="id" title="var">PO</span> <span class="id" title="var">SO</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">some_si</span> : <span class="id" title="var">SI</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">PI</span> → <span class="id" title="var">SI</span> → <span class="id" title="var">PO</span>×<span class="id" title="var">SO</span>) <span class="id" title="var">pi</span> <span class="id" title="var">si</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">fst</span> (<span class="id" title="var">f</span> <span class="id" title="var">pi</span> <span class="id" title="var">some_si</span>), <span class="id" title="var">snd</span> (<span class="id" title="var">f</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>)).<br/>
</div>

<div class="doc">
Functions protected by <span class="inlinecode"><span class="id" title="var">sme</span></span> are guaranteed to satisfy noninterference: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">noninterferent_sme</span> :  <span class="id" title="keyword">∀</span> <span class="id" title="var">PI</span> <span class="id" title="var">SI</span> <span class="id" title="var">PO</span> <span class="id" title="var">SO</span> : <span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">some_si</span> : <span class="id" title="var">SI</span>,<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">f</span> : <span class="id" title="var">PI</span> → <span class="id" title="var">SI</span> → <span class="id" title="var">PO</span>×<span class="id" title="var">SO</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">noninterferent</span> (<span class="id" title="var">sme</span> <span class="id" title="var">some_si</span> <span class="id" title="var">f</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">PI</span> <span class="id" title="var">SI</span> <span class="id" title="var">PO</span> <span class="id" title="var">SO</span> <span class="id" title="var">some_si</span> <span class="id" title="var">f</span> <span class="id" title="var">pi</span> <span class="id" title="var">si<sub>1</sub></span> <span class="id" title="var">si<sub>2</sub></span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Moreover, if the function we pass to <span class="inlinecode"><span class="id" title="var">sme</span></span> is already noninterferent,
    then its behavior will not change; so we say that <span class="inlinecode"><span class="id" title="var">sme</span></span> is a <i>transparent</i>
    enforcement mechanism for noninterference: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">transparent_sme</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">PI</span> <span class="id" title="var">SI</span> <span class="id" title="var">PO</span> <span class="id" title="var">SO</span> : <span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">some_si</span> : <span class="id" title="var">SI</span>,<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">f</span> : <span class="id" title="var">PI</span> → <span class="id" title="var">SI</span> → <span class="id" title="var">PO</span>×<span class="id" title="var">SO</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">noninterferent</span> <span class="id" title="var">f</span> → <span class="id" title="keyword">∀</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>, <span class="id" title="var">f</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span> = <span class="id" title="var">sme</span> <span class="id" title="var">some_si</span> <span class="id" title="var">f</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent</span>, <span class="id" title="var">sme</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">PI</span> <span class="id" title="var">SI</span> <span class="id" title="var">PO</span> <span class="id" title="var">SP</span> <span class="id" title="var">some_si</span> <span class="id" title="var">f</span> <span class="id" title="var">Hni</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">Hni</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">si</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">f</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">po</span> <span class="id" title="var">so</span>]. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
It is interesting to look at what <span class="inlinecode"><span class="id" title="var">sme</span></span> does for <i>interferent</i> functions,
    like <span class="inlinecode"><span class="id" title="var">insecure_f</span></span>, whose public output was one plus its secret input: 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <span class="id" title="var">example1_sme_insecure_f</span>: <span class="id" title="var">sme</span> 0 <span class="id" title="var">insecure_f</span> 0 0 = (1, 0).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">example2_sme_insecure_f</span>: <span class="id" title="var">sme</span> 0 <span class="id" title="var">insecure_f</span> 0 1 = (1, 2).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">example3_sme_insecure_f</span>: <span class="id" title="var">sme</span> 0 <span class="id" title="var">insecure_f</span> 1 1 = (1, 3).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Now the public output is one plus the dummy constant <span class="inlinecode">0</span> we passed to the
   <span class="inlinecode"><span class="id" title="var">sme</span></span> function, so always the constant <span class="inlinecode">1</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">constant_sme_insecure_f</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">fst</span> (<span class="id" title="var">sme</span> 0 <span class="id" title="var">insecure_f</span> <span class="id" title="var">pi</span> <span class="id" title="var">si</span>) = 1.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
This is a secure behavior, but a behavior that's different than that of the
    original <span class="inlinecode"><span class="id" title="var">insecure_f</span></span> function. So we are giving up some correctness for
    security. There is no free lunch! 
<div class="paragraph"> </div>

 The other downside of <span class="inlinecode"><span class="id" title="var">sme</span></span> is that we have to run the function twice for
    our two security levels, public and secret. In general, we need to run the
    program as many times as we have security levels, which is often an
    exponential number, say if we take our security levels to be sets of
    principals.

<div class="paragraph"> </div>

    Other information flow control mechanisms overcome this downside, but have
    other downsides of their own, for instance:
<ul class="doclist">
<li> by requiring complex manual proofs for each individual program
          (e.g. Relational Hoare Logic), or

</li>
<li> by using static overapproximations that reject some secure programs
          (security type systems), or

</li>
<li> by using dynamic overapproximations that unnecessarily change program
          behavior, for instance stopping even some secure to prevent leaks, in
          which case they are not transparent (dynamic information flow control).

</li>
</ul>

<div class="paragraph"> </div>

    Again, there is no free lunch! 
<div class="paragraph"> </div>

<a id="lab445"></a><h2 class="section">Noninterference for state transformers</h2>

<div class="paragraph"> </div>

 This development is easy to adapt to functions that transform states
    (<span class="inlinecode"><span class="id" title="var">state</span>→<span class="id" title="var">state</span></span>), where we label each variable as either public or secret. 
</div>
<div class="code">

<span class="id" title="keyword">From</span> <span class="id" title="var">Coq</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Bool.Bool</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Coq</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Init.Nat</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Coq</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith.Arith</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Coq</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith.EqNat</span>. <span class="id" title="keyword">Import</span> <span class="id" title="var">Nat</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">LF</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Maps</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">LF</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Imp</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">state</span>. <span class="comment">(*&nbsp;state&nbsp;=&nbsp;total_map&nbsp;nat&nbsp;=&nbsp;string&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;nat&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pub_map</span> := <span class="id" title="var">total_map</span> <span class="id" title="var">bool</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pub_equiv</span> (<span class="id" title="var">pub</span> : <span class="id" title="var">pub_map</span>) (<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> : <span class="id" title="var">state</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>:<span class="id" title="var">string</span>, <span class="id" title="var">pub</span> <span class="id" title="var">x</span> = <span class="id" title="var">true</span> → <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">x</span> = <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">x</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">noninterferent_state</span> (<span class="id" title="var">pub</span> : <span class="id" title="var">pub_map</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">state</span> → <span class="id" title="var">state</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span>, <span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> → <span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> (<span class="id" title="var">f</span> <span class="id" title="var">s<sub>1</sub></span>) (<span class="id" title="var">f</span> <span class="id" title="var">s<sub>2</sub></span>).<br/>
</div>

<div class="doc">
We can prove an equivalence between <span class="inlinecode"><span class="id" title="var">noninterferent_state</span></span> and our original
    <span class="inlinecode"><span class="id" title="var">noninterferent</span></span> definition. For this we need to split and merge states,
    and a few helper lemmas. 
<div class="paragraph"> </div>

 The way we define <span class="inlinecode"><span class="id" title="var">split_state</span></span> and <span class="inlinecode"><span class="id" title="var">merge_state</span></span> is a good example of
    programming with higher-order functions, and there's more of this in
    <a href="Maps.html"><span class="inlineref">Maps</span></a>.

<div class="paragraph"> </div>

    The <span class="inlinecode"><span class="id" title="var">split_state</span></span> function takes a state <span class="inlinecode"><span class="id" title="var">s</span></span> and zeroes out the variables
    <span class="inlinecode"><span class="id" title="var">x</span></span> for which <span class="inlinecode"><span class="id" title="var">pub</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> is different than an argument bit <span class="inlinecode"><span class="id" title="var">b</span></span>. So
    <span class="inlinecode"><span class="id" title="var">split_state</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode"><span class="id" title="var">pub</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> keeps the public variables, and zeroes out the
    secret ones. Dually, <span class="inlinecode"><span class="id" title="var">split_state</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode"><span class="id" title="var">pub</span></span> <span class="inlinecode"><span class="id" title="var">false</span></span> keeps the secret variables,
    and zeroes out the public ones.  
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">split_state</span> (<span class="id" title="var">s</span>:<span class="id" title="var">state</span>) (<span class="id" title="var">pub</span>:<span class="id" title="var">pub_map</span>) (<span class="id" title="var">b</span>:<span class="id" title="var">bool</span>) : <span class="id" title="var">state</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">string</span> ⇒ <span class="id" title="keyword">if</span> <span class="id" title="var">Bool.eqb</span> (<span class="id" title="var">pub</span> <span class="id" title="var">x</span>) <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">s</span> <span class="id" title="var">x</span> <span class="id" title="keyword">else</span> 0.<br/><hr class='doublespaceincode'/>
<span class="comment">(*&nbsp;The&nbsp;<span class="inlinecode"><span class="id" title="var">merge_state</span></span>&nbsp;function&nbsp;takes&nbsp;in&nbsp;two&nbsp;states&nbsp;<span class="inlinecode"><span class="id" title="var">s<sub>1</sub></span></span>&nbsp;and&nbsp;<span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span>&nbsp;and&nbsp;produces&nbsp;a<br/>
&nbsp;&nbsp;&nbsp;new&nbsp;state&nbsp;that&nbsp;contains&nbsp;the&nbsp;public&nbsp;variables&nbsp;from&nbsp;<span class="inlinecode"><span class="id" title="var">s<sub>1</sub></span></span>&nbsp;and&nbsp;the&nbsp;private<br/>
&nbsp;&nbsp;&nbsp;variables&nbsp;from&nbsp;<span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span>.&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">merge_states</span> (<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span>:<span class="id" title="var">state</span>) (<span class="id" title="var">pub</span>:<span class="id" title="var">pub_map</span>) : <span class="id" title="var">state</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">string</span> ⇒ <span class="id" title="keyword">if</span> <span class="id" title="var">pub</span> <span class="id" title="var">x</span> <span class="id" title="keyword">then</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">x</span> <span class="id" title="keyword">else</span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">x</span>.<br/>
</div>

<div class="doc">
The technical development needed for the equivalence proof between
    <span class="inlinecode"><span class="id" title="var">noninterferent_state</span></span> and our original <span class="inlinecode"><span class="id" title="var">noninterferent</span></span> definition is not
    that interesting though, and can be skipped on first read. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">split_state_fun</span> (<span class="id" title="var">pub</span> : <span class="id" title="var">pub_map</span>) (<span class="id" title="var">mf</span> : <span class="id" title="var">state</span> → <span class="id" title="var">state</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> : <span class="id" title="var">state</span> ⇒ <span class="id" title="keyword">let</span> <span class="id" title="var">ms</span> := <span class="id" title="var">mf</span> (<span class="id" title="var">merge_states</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">pub</span>) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">split_state</span> <span class="id" title="var">ms</span> <span class="id" title="var">pub</span> <span class="id" title="var">true</span>, <span class="id" title="var">split_state</span> <span class="id" title="var">ms</span> <span class="id" title="var">pub</span> <span class="id" title="var">false</span>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pub_equiv_split</span> (<span class="id" title="var">pub</span> : <span class="id" title="var">pub_map</span>) (<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> : <span class="id" title="var">state</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>:<span class="id" title="var">string</span>, (<span class="id" title="var">split_state</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">pub</span> <span class="id" title="var">true</span>) <span class="id" title="var">x</span> = (<span class="id" title="var">split_state</span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">pub</span> <span class="id" title="var">true</span>) <span class="id" title="var">x</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">pub_equiv_split_iff</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> ↔ <span class="id" title="var">pub_equiv_split</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">pub_equiv</span>, <span class="id" title="var">pub_equiv_split</span>, <span class="id" title="var">split_state</span>. <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">Bool.eqb_spec</span> (<span class="id" title="var">pub</span> <span class="id" title="var">x</span>) <span class="id" title="var">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">e</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> <span class="id" title="var">x</span>). <span class="id" title="tactic">destruct</span> (<span class="id" title="var">Bool.eqb_spec</span> (<span class="id" title="var">pub</span> <span class="id" title="var">x</span>) <span class="id" title="var">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">_</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">contradiction</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">pub_equiv_merge_states</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">pub</span> <span class="id" title="var">s</span> <span class="id" title="var">z<sub>1</sub></span> <span class="id" title="var">z<sub>2</sub></span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> (<span class="id" title="var">merge_states</span> <span class="id" title="var">s</span> <span class="id" title="var">z<sub>1</sub></span> <span class="id" title="var">pub</span>) (<span class="id" title="var">merge_states</span> <span class="id" title="var">s</span> <span class="id" title="var">z<sub>2</sub></span> <span class="id" title="var">pub</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">pub_equiv</span>, <span class="id" title="var">merge_states</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">pub</span> <span class="id" title="var">s</span> <span class="id" title="var">z<sub>1</sub></span> <span class="id" title="var">z<sub>2</sub></span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hx</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">FunctionalExtensionality</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">merge_states_split_state</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s</span> <span class="id" title="var">pub</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">merge_states</span> (<span class="id" title="var">split_state</span> <span class="id" title="var">s</span> <span class="id" title="var">pub</span> <span class="id" title="var">true</span>) (<span class="id" title="var">split_state</span> <span class="id" title="var">s</span> <span class="id" title="var">pub</span> <span class="id" title="var">false</span>) <span class="id" title="var">pub</span> = <span class="id" title="var">s</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">merge_states</span>, <span class="id" title="var">split_state</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s</span> <span class="id" title="var">pub</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">functional_extensionality</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">pub</span> <span class="id" title="var">x</span>) <span class="id" title="var">eqn</span>:<span class="id" title="var">Heq</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Now we can finally state our theorem about the equivalence between
    <span class="inlinecode"><span class="id" title="var">non_interferent_state</span></span> and <span class="inlinecode"><span class="id" title="var">noninterferent</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">noninterferent_state_ni</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">pub</span> <span class="id" title="var">f</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent_state</span> <span class="id" title="var">pub</span> <span class="id" title="var">f</span> ↔<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent</span> (<span class="id" title="var">split_state_fun</span> <span class="id" title="var">pub</span> <span class="id" title="var">f</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent_state</span>, <span class="id" title="var">noninterferent</span>, <span class="id" title="var">split_state_fun</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">pub</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span> <span class="id" title="var">s</span> <span class="id" title="var">z<sub>1</sub></span> <span class="id" title="var">z<sub>2</sub></span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H'</span> : <span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> (<span class="id" title="var">merge_states</span> <span class="id" title="var">s</span> <span class="id" title="var">z<sub>1</sub></span> <span class="id" title="var">pub</span>) (<span class="id" title="var">merge_states</span> <span class="id" title="var">s</span> <span class="id" title="var">z<sub>2</sub></span> <span class="id" title="var">pub</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> <span class="id" title="var">pub_equiv_merge_states</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H'</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">pub_equiv_split_iff</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">pub_equiv_split</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H'</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">functional_extensionality</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H'</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">Hequiv</span>. <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">pub_equiv_split_iff</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hequiv</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">pub_equiv_split</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hequiv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">pub_equiv_split_iff</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">pub_equiv_split</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> (<span class="id" title="var">split_state</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">pub</span> <span class="id" title="var">true</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">split_state</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">pub</span> <span class="id" title="var">false</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">split_state</span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">pub</span> <span class="id" title="var">false</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">merge_states_split_state</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">functional_extensionality</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hequiv</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hequiv</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">merge_states_split_state</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab446"></a><h2 class="section">SME for state transformers</h2>

</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">sme_state</span> (<span class="id" title="var">f</span> : <span class="id" title="var">state</span> → <span class="id" title="var">state</span>) (<span class="id" title="var">pub</span>:<span class="id" title="var">pub_map</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <span class="id" title="var">merge_states</span> (<span class="id" title="var">f</span> (<span class="id" title="var">split_state</span> <span class="id" title="var">s</span> <span class="id" title="var">pub</span> <span class="id" title="var">true</span>)) (<span class="id" title="var">f</span> <span class="id" title="var">s</span>) <span class="id" title="var">pub</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">noninterferent_sme_state</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">pub</span> <span class="id" title="var">f</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent_state</span> <span class="id" title="var">pub</span> (<span class="id" title="var">sme_state</span> <span class="id" title="var">f</span> <span class="id" title="var">pub</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent_state</span>, <span class="id" title="var">sme_state</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">pub</span> <span class="id" title="var">f</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">Hequiv</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">pub_equiv_split_iff</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hequiv</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">pub_equiv_split</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hequiv</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">functional_extensionality</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hequiv</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hequiv</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">pub_equiv_merge_states</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">transparent_sme_state</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">f</span> <span class="id" title="var">pub</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent_state</span> <span class="id" title="var">pub</span> <span class="id" title="var">f</span> → <span class="id" title="keyword">∀</span> <span class="id" title="var">s</span>, <span class="id" title="var">f</span> <span class="id" title="var">s</span> = <span class="id" title="var">sme_state</span> <span class="id" title="var">f</span> <span class="id" title="var">pub</span> <span class="id" title="var">s</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent_state</span>, <span class="id" title="var">sme_state</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> <span class="id" title="var">pub</span> <span class="id" title="var">Hni</span> <span class="id" title="var">s</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">merge_states</span>, <span class="id" title="var">split_state</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">pub_equiv</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hni</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">functional_extensionality</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">pub</span> <span class="id" title="var">x</span>) <span class="id" title="var">eqn</span>:<span class="id" title="var">Eq</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">Hni</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">x'</span> <span class="id" title="var">Hx'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">Bool.eqb_spec</span> (<span class="id" title="var">pub</span> <span class="id" title="var">x'</span>) <span class="id" title="var">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
One thing to note in this proof is that we used the lemma <span class="inlinecode"><span class="id" title="var">Bool.eqb_spec</span></span> to
    do case analysis on whether the <span class="inlinecode"><span class="id" title="var">pub</span></span> <span class="inlinecode"><span class="id" title="var">x'</span></span> is equal to <span class="inlinecode"><span class="id" title="var">true</span></span>. For more
    details on how this works, please check out the explanations about the
    <span class="inlinecode"><span class="id" title="var">reflect</span></span> inductive predicate in <a href="IndProp.html"><span class="inlineref">IndProp</span></a>. 
<div class="paragraph"> </div>

<a id="lab447"></a><h2 class="section">Noninterference and SME for Imp programs without loops</h2>

<div class="paragraph"> </div>

 For programs without loops the "failed attempt" evaluation function from
   <a href="Imp.html"><span class="inlineref">Imp</span></a> works well and allows us to easily define a state transformer
   function for each command. 
</div>
<div class="code">

<span class="id" title="keyword">Print</span> <span class="id" title="var">ceval_fun_no_while</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">noninterferent_no_while</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span> : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent_state</span> <span class="id" title="var">pub</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <span class="id" title="var">ceval_fun_no_while</span> <span class="id" title="var">s</span> <span class="id" title="var">c</span>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">xpub</span> : <span class="id" title="var">pub_map</span> :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" title="var">true</span>;<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> <span class="id" title="var">false</span>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">secure_com</span> : <span class="id" title="var">com</span> :=<br/>
&nbsp;&nbsp;&lt;{ <span class="id" title="var">X</span> := <span class="id" title="var">X</span>+1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Y</span> := <span class="id" title="var">X</span>+<span class="id" title="var">Y</span>*2 }&gt;.<br/>
</div>

<div class="doc">
For proving <span class="inlinecode"><span class="id" title="var">secure_com</span></span> noninterferent we first prove a few
    helper lemmas. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">xpub_true</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">xpub</span> <span class="id" title="var">x</span> = <span class="id" title="var">true</span> → <span class="id" title="var">x</span> = <span class="id" title="var">X</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">xpub</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">eqb_spec</span> <span class="id" title="var">x</span> <span class="id" title="var">X</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">rewrite</span> <span class="id" title="var">t_update_neq</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">t_apply_empty</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hx</span>. <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intro</span> <span class="id" title="var">contra</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="var">contradiction</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Here we are using the <span class="inlinecode"><span class="id" title="var">t_update_neq</span></span> and <span class="inlinecode"><span class="id" title="var">t_apply_empty</span></span> lemmas that were
    proved in <a href="Maps.html"><span class="inlineref">Maps</span></a> 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">xpubX</span> : <span class="id" title="var">xpub</span> <span class="id" title="var">X</span> = <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Using these lemmas the noninterference proof for <span class="inlinecode"><span class="id" title="var">secure_com</span></span> is easy: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">noninterferent_secore_com</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent_no_while</span> <span class="id" title="var">xpub</span> <span class="id" title="var">secure_com</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent_no_while</span>, <span class="id" title="var">noninterferent_state</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">secure_com</span>, <span class="id" title="var">pub_equiv</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">H</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">xpub_true</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="tactic">rewrite</span> (<span class="id" title="var">H</span> <span class="id" title="var">X</span> <span class="id" title="var">xpubX</span>). <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Now let's look at a couple of insecure commands: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">insecure_com1</span> : <span class="id" title="var">com</span> :=<br/>
&nbsp;&nbsp;&lt;{ <span class="id" title="var">X</span> := <span class="id" title="var">Y</span>+1; <span class="comment">(*&nbsp;&lt;-&nbsp;bad&nbsp;explicit&nbsp;flow!&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Y</span> := <span class="id" title="var">X</span>+<span class="id" title="var">Y</span>*2 }&gt;.<br/>
</div>

<div class="doc">
An <i>explicit flow</i> is when a command directly assigns an expression
    depending on secret variables to a public variable, like the <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">Y</span>+1</span>
    assignment above. We can prove that this is insecure: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">interferent_secore_com1</span> :<br/>
&nbsp;&nbsp;¬<span class="id" title="var">noninterferent_no_while</span> <span class="id" title="var">xpub</span> <span class="id" title="var">insecure_com1</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent_no_while</span>, <span class="id" title="var">noninterferent_state</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">insecure_com1</span>, <span class="id" title="var">pub_equiv</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">Hc</span>. <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hc</span> (<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0 ; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0) (<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0 ; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 1)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">xpub</span> <span class="id" title="var">x</span> = <span class="id" title="var">true</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0) <span class="id" title="var">x</span> = (<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 1) <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">clear</span> <span class="id" title="var">Hc</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">xpub_true</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hc</span> <span class="id" title="var">H</span> <span class="id" title="var">X</span> <span class="id" title="var">xpubX</span>). <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">try</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">t_update_eq</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">discriminate</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Noninterference can be violated not only by explicit flows, but also by
    <i>implicit flows</i>, which leak secret information via the control-flow of the
    program. Here is a simple example: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">insecure_com2</span> : <span class="id" title="var">com</span> :=<br/>
&nbsp;&nbsp;&lt;{ <span class="id" title="keyword">if</span> <span class="id" title="var">Y</span> = 0 <span class="id" title="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Y</span> := 42<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">X</span> := <span class="id" title="var">X</span>+1 <span class="comment">(*&nbsp;&lt;-&nbsp;bad&nbsp;implicit&nbsp;flow!&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> }&gt;.<br/>
</div>

<div class="doc">
Here the expression <span class="inlinecode"><span class="id" title="var">X</span>+1</span> we are assigning to <span class="inlinecode"><span class="id" title="var">X</span></span> is public information, but
    we are doing this assignment after we branched on a secret condition <span class="inlinecode"><span class="id" title="var">Y</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode">0</span>, so we are indirectly leaking information about the value of <span class="inlinecode"><span class="id" title="var">Y</span></span>. In this
    case we can infer that if <span class="inlinecode"><span class="id" title="var">X</span></span> gets incremented the value of <span class="inlinecode"><span class="id" title="var">Y</span></span> is not <span class="inlinecode">0</span>. 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">interferent_secore_com2</span> :<br/>
&nbsp;&nbsp;¬<span class="id" title="var">noninterferent_no_while</span> <span class="id" title="var">xpub</span> <span class="id" title="var">insecure_com2</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;same&nbsp;insecurity&nbsp;proof&nbsp;as&nbsp;for&nbsp;<span class="inlinecode"><span class="id" title="var">insecure_com1</span></span>&nbsp;does&nbsp;the&nbsp;job&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent_no_while</span>, <span class="id" title="var">noninterferent_state</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">insecure_com2</span>, <span class="id" title="var">pub_equiv</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">Hc</span>. <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hc</span> (<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0 ; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0) (<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0 ; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 1)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">xpub</span> <span class="id" title="var">x</span> = <span class="id" title="var">true</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0) <span class="id" title="var">x</span> = (<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 1) <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">clear</span> <span class="id" title="var">Hc</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">xpub_true</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hc</span> <span class="id" title="var">H</span> <span class="id" title="var">X</span> <span class="id" title="var">xpubX</span>). <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">try</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">t_update_eq</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">discriminate</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
We can use <span class="inlinecode"><span class="id" title="var">sme_state</span></span> to execute such programs to obtain a noninterferent
    state transformer, by running them 2 times, once on a state without secrets
    and once on the original input state and then merging the final states. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">sme_cmd</span> <span class="id" title="var">c</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">sme_state</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <span class="id" title="var">ceval_fun_no_while</span> <span class="id" title="var">s</span> <span class="id" title="var">c</span>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">sme_insecure_com1</span> := <span class="id" title="var">sme_cmd</span> <span class="id" title="var">insecure_com1</span> <span class="id" title="var">xpub</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">sme_insecure_com2</span> := <span class="id" title="var">sme_cmd</span> <span class="id" title="var">insecure_com2</span> <span class="id" title="var">xpub</span>.<br/>
</div>

<div class="doc">
The result of applying <span class="inlinecode"><span class="id" title="var">sme_cmd</span></span> to a program is no longer a program, but a
    state transformer. We can prove them noninterferent as state transformers
    using our noninterference theorem about <span class="inlinecode"><span class="id" title="var">sme_state</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">noninterferent_sme_insecure_com1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent_state</span> <span class="id" title="var">xpub</span> <span class="id" title="var">sme_insecure_com1</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">noninterferent_sme_state</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">noninterferent_sme_insecure_com2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent_state</span> <span class="id" title="var">xpub</span> <span class="id" title="var">sme_insecure_com2</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">noninterferent_sme_state</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab448"></a><h2 class="section">Noninterference and SME for Imp programs with loops</h2>

<div class="paragraph"> </div>

 In the presence of loops, we need to define noninterference using the
    evaluation relation (<span class="inlinecode"><span class="id" title="var">ceval</span></span>) of Imp: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">noninterferent_while</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">s<sub>2</sub>'</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> =[ <span class="id" title="var">c</span> ]=&gt; <span class="id" title="var">s<sub>1</sub>'</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>2</sub></span> =[ <span class="id" title="var">c</span> ]=&gt; <span class="id" title="var">s<sub>2</sub>'</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">s<sub>2</sub>'</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">invert</span> <span class="id" title="var">H</span> := <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">noninterferent_secore_com'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent_while</span> <span class="id" title="var">xpub</span> <span class="id" title="var">secure_com</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent_while</span>, <span class="id" title="var">secure_com</span>, <span class="id" title="var">pub_equiv</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">H</span> <span class="id" title="var">H<sub>1</sub></span> <span class="id" title="var">H<sub>2</sub></span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">xpub_true</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hx</span>. <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;the&nbsp;proof&nbsp;is&nbsp;the&nbsp;same,&nbsp;but&nbsp;with&nbsp;some&nbsp;extra&nbsp;ugly&nbsp;<span class="inlinecode"><span class="id" title="var">invert</span></span>s&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="var">invert</span> <span class="id" title="var">H<sub>1</sub></span>. <span class="id" title="var">invert</span> <span class="id" title="var">H<sub>4</sub></span>. <span class="id" title="var">invert</span> <span class="id" title="var">H<sub>7</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">invert</span> <span class="id" title="var">H<sub>2</sub></span>. <span class="id" title="var">invert</span> <span class="id" title="var">H<sub>3</sub></span>. <span class="id" title="var">invert</span> <span class="id" title="var">H<sub>6</sub></span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">H</span> <span class="id" title="var">X</span> <span class="id" title="var">xpubX</span>). <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Now to define SME we also need to use a relation,
    of a similar type to <span class="inlinecode"><span class="id" title="var">ceval</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Check</span> <span class="id" title="var">ceval</span> : <span class="id" title="var">com</span> → <span class="id" title="var">state</span> → <span class="id" title="var">state</span> → <span class="id" title="keyword">Prop</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">sme_while</span> (<span class="id" title="var">pub</span>:<span class="id" title="var">pub_map</span>) (<span class="id" title="var">c</span>:<span class="id" title="var">com</span>) (<span class="id" title="var">s</span> <span class="id" title="var">s'</span>:<span class="id" title="var">state</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">ps</span> <span class="id" title="var">ss</span>, <span class="id" title="var">split_state</span> <span class="id" title="var">s</span> <span class="id" title="var">pub</span> <span class="id" title="var">true</span> =[ <span class="id" title="var">c</span> ]=&gt; <span class="id" title="var">ps</span> ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">s</span> =[ <span class="id" title="var">c</span> ]=&gt; <span class="id" title="var">ss</span> ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge_states</span> <span class="id" title="var">ps</span> <span class="id" title="var">ss</span> <span class="id" title="var">pub</span> = <span class="id" title="var">s'</span>.<br/>
</div>

<div class="doc">
To state that sme_eval is secure, we need to generalize our noninterference
    definition, so that it works not only with <span class="inlinecode"><span class="id" title="var">ceval</span></span>, but with any evaluation
    relation, including <span class="inlinecode"><span class="id" title="var">sme_while</span></span> <span class="inlinecode"><span class="id" title="var">pub</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">noninterferent_while_R</span> (<span class="id" title="var">R</span>:<span class="id" title="var">com</span>→<span class="id" title="var">state</span>→<span class="id" title="var">state</span>→<span class="id" title="keyword">Prop</span>) <span class="id" title="var">pub</span> <span class="id" title="var">c</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">s<sub>2</sub>'</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">R</span> <span class="id" title="var">c</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>1</sub>'</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">R</span> <span class="id" title="var">c</span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">s<sub>2</sub>'</span>.<br/>
</div>

<div class="doc">
The proof that <span class="inlinecode"><span class="id" title="var">while_sme</span></span> is noninterferent is as before, but now it relies
    on the determinism of <span class="inlinecode"><span class="id" title="var">ceval</span></span>, which was obvious for state transformer
    functions, but is not obvious for evaluation relations. 
</div>
<div class="code">

<span class="id" title="keyword">Check</span> <span class="id" title="var">ceval_deterministic</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">c</span> : <span class="id" title="var">com</span>) (<span class="id" title="var">st</span> <span class="id" title="var">st<sub>1</sub></span> <span class="id" title="var">st<sub>2</sub></span> : <span class="id" title="var">state</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">st</span> =[ <span class="id" title="var">c</span> ]=&gt; <span class="id" title="var">st<sub>1</sub></span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">st</span> =[ <span class="id" title="var">c</span> ]=&gt; <span class="id" title="var">st<sub>2</sub></span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">st<sub>1</sub></span> = <span class="id" title="var">st<sub>2</sub></span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">noninterferent_while_sme</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent_while_R</span> (<span class="id" title="var">sme_while</span> <span class="id" title="var">pub</span>) <span class="id" title="var">pub</span> <span class="id" title="var">c</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent_while_R</span>, <span class="id" title="var">sme_while</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">H</span> [<span class="id" title="var">ps<sub>1</sub></span> [<span class="id" title="var">ss<sub>1</sub></span> [<span class="id" title="var">H1p</span> [<span class="id" title="var">H1s</span> <span class="id" title="var">H1m</span>]]]]<br/>
                               [<span class="id" title="var">ps<sub>2</sub></span> [<span class="id" title="var">ss<sub>2</sub></span> [<span class="id" title="var">H2p</span> [<span class="id" title="var">H2s</span> <span class="id" title="var">H2m</span>]]]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">pub_equiv_split_iff</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">pub_equiv_split</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">functional_extensionality</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H1p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">ceval_deterministic</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H1p</span> <span class="id" title="var">H2p</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">pub_equiv_merge_states</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Turns out we can only prove a weak version of transparency, and this has to
    do with nontermination (more later). But first we need a few lemmas:  
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">pub_equiv_split_state</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">pub</span>:<span class="id" title="var">pub_map</span>) <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> (<span class="id" title="var">split_state</span> <span class="id" title="var">s</span> <span class="id" title="var">pub</span> <span class="id" title="var">true</span>) <span class="id" title="var">s</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">pub_equiv</span>, <span class="id" title="var">split_state</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">pub</span> <span class="id" title="var">s</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">Bool.eqb_spec</span> (<span class="id" title="var">pub</span> <span class="id" title="var">x</span>) <span class="id" title="var">true</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. <span class="id" title="var">contradiction</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">pub_equiv_sym</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">pub</span>:<span class="id" title="var">pub_map</span>) <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">s<sub>1</sub></span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">pub_equiv</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">H</span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">merge_state_pub_equiv</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">pub</span> <span class="id" title="var">ss</span> <span class="id" title="var">ps</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">ss</span> <span class="id" title="var">ps</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">merge_states</span> <span class="id" title="var">ps</span> <span class="id" title="var">ss</span> <span class="id" title="var">pub</span> = <span class="id" title="var">ss</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">pub_equiv</span>, <span class="id" title="var">merge_states</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">pub</span> <span class="id" title="var">ss</span> <span class="id" title="var">ps</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">functional_extensionality</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">pub</span> <span class="id" title="var">x</span>) <span class="id" title="var">eqn</span>:<span class="id" title="var">Heq</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
More specifically, we can only prove that <span class="inlinecode"><span class="id" title="var">sme_while</span></span> execution implies
    <span class="inlinecode"><span class="id" title="var">ceval</span></span>. But we cannot prove the reverse implication, since a command
    terminating when starting in state <span class="inlinecode"><span class="id" title="var">s</span></span>, does not necessarily still
    terminates when starting in state <span class="inlinecode"><span class="id" title="var">split_state</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode"><span class="id" title="var">pub</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>, as would be
    needed for proving <span class="inlinecode"><span class="id" title="var">sme_while</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">somewhat_transparent_while_sme</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent_while</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span> →<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">s</span> <span class="id" title="var">s'</span>, (<span class="id" title="var">sme_while</span> <span class="id" title="var">pub</span>) <span class="id" title="var">c</span> <span class="id" title="var">s</span> <span class="id" title="var">s'</span> → <span class="id" title="var">s</span> =[ <span class="id" title="var">c</span> ]=&gt; <span class="id" title="var">s'</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent_while</span>, <span class="id" title="var">sme_while</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span> <span class="id" title="var">Hni</span> <span class="id" title="var">s</span> <span class="id" title="var">s'</span> [<span class="id" title="var">ps</span> [<span class="id" title="var">ss</span> [<span class="id" title="var">Hp</span> [<span class="id" title="var">Hs</span> <span class="id" title="var">Hm</span>]]]]. <span class="id" title="tactic">subst</span> <span class="id" title="var">s'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span>(<span class="id" title="var">H</span>:<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s</span> (<span class="id" title="var">split_state</span> <span class="id" title="var">s</span> <span class="id" title="var">pub</span> <span class="id" title="var">true</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> <span class="id" title="var">pub_equiv_sym</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">pub_equiv_split_state</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hni</span> <span class="id" title="var">s</span> (<span class="id" title="var">split_state</span> <span class="id" title="var">s</span> <span class="id" title="var">pub</span> <span class="id" title="var">true</span>) <span class="id" title="var">ss</span> <span class="id" title="var">ps</span> <span class="id" title="var">H</span> <span class="id" title="var">Hs</span> <span class="id" title="var">Hp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">merge_state_pub_equiv</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hni</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hni</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">Hs</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Still, it seems we can still do the same things as in the setting without
    while loops, including SME (just not fully transparent). So is there
    anything special about loops and nontermination?

<div class="paragraph"> </div>

    Yes, there is! Let's look at our noninterference definition again:
<br/>
<span class="inlinecode"><span class="id" title="keyword">Definition</span> <span class="id" title="var">noninterferent_while</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">s<sub>2</sub>'</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> =[ <span class="id" title="var">c</span> ]=&gt; <span class="id" title="var">s<sub>1</sub>'</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>2</sub></span> =[ <span class="id" title="var">c</span> ]=&gt; <span class="id" title="var">s<sub>2</sub>'</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">s<sub>2</sub>'</span>.
</span>    It says that for any two <i>terminating</i> executions, if the initial states
    agree on their public variables, then so do the final states. This is
    traditionally called <i>termination-insensitive</i> noninterference (TINI),
    since it doesn't consider nontermination to be observable to an attacker.

<div class="paragraph"> </div>

    In particular, the following program is considered secure wrt TINI: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">termination_leak</span> : <span class="id" title="var">com</span> :=<br/>
&nbsp;&nbsp;&lt;{ <span class="id" title="keyword">if</span> <span class="id" title="var">Y</span> = 0 <span class="id" title="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Y</span> := 42<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">while</span> <span class="id" title="var">true</span> <span class="id" title="tactic">do</span> <span class="id" title="var">skip</span> <span class="id" title="keyword">end</span> <span class="comment">(*&nbsp;&lt;-&nbsp;we&nbsp;leak&nbsp;the&nbsp;secret&nbsp;by&nbsp;looping&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> }&gt;.<br/>
</div>

<div class="doc">
And we can prove it ... 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Y_neq_X</span> : (<span class="id" title="var">Y</span> ≠ <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">intro</span> <span class="id" title="var">contra</span>. <span class="id" title="tactic">discriminate</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">loop_never_stops</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">st</span> <span class="id" title="var">st'</span>,<br/>
&nbsp;&nbsp;~(<span class="id" title="var">st</span> =[ <span class="id" title="var">loop</span> ]=&gt; <span class="id" title="var">st'</span>).<br/>
<span class="id" title="var">Admitted</span>. <span class="comment">(*&nbsp;this&nbsp;one&nbsp;is&nbsp;a&nbsp;homework&nbsp;exercise&nbsp;in&nbsp;Imp&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tini_secure_termination_leak</span> :<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent_while</span> <span class="id" title="var">xpub</span> <span class="id" title="var">termination_leak</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent_while</span>, <span class="id" title="var">termination_leak</span>, <span class="id" title="var">pub_equiv</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">H</span> <span class="id" title="var">H<sub>1</sub></span> <span class="id" title="var">H<sub>2</sub></span> <span class="id" title="var">x</span> <span class="id" title="var">Hx</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">xpub_true</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hx</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">H</span> <span class="id" title="var">X</span> <span class="id" title="var">xpubX</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">invert</span> <span class="id" title="var">H<sub>1</sub></span>.<br/>
&nbsp;&nbsp;+ <span class="id" title="var">invert</span> <span class="id" title="var">H<sub>8</sub></span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">t_update_neq</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Y_neq_X</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">invert</span> <span class="id" title="var">H<sub>2</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="var">invert</span> <span class="id" title="var">H<sub>8</sub></span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">t_update_neq</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Y_neq_X</span>). <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">apply</span> <span class="id" title="var">loop_never_stops</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H<sub>8</sub></span>. <span class="id" title="var">contradiction</span>.<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">loop_never_stops</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H<sub>8</sub></span>. <span class="id" title="var">contradiction</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab449"></a><h2 class="section">Termination-Sensitive Noninterference</h2>

<div class="paragraph"> </div>

 We can give a stronger definition of security that prevents such
    nontermination leaks. It is traditionally called <i>termination-sensitive
    noninterference</i> (TSNI) and it is defined as follows: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">tsni_while_R</span> (<span class="id" title="var">R</span>:<span class="id" title="var">com</span>→<span class="id" title="var">state</span>→<span class="id" title="var">state</span>→<span class="id" title="keyword">Prop</span>) <span class="id" title="var">pub</span> <span class="id" title="var">c</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">s<sub>1</sub>'</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">R</span> <span class="id" title="var">c</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>1</sub>'</span> →<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">∃</span> <span class="id" title="var">s<sub>2</sub>'</span>, <span class="id" title="var">R</span> <span class="id" title="var">c</span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> ∧ <span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">s<sub>2</sub>'</span>).<br/>
</div>

<div class="doc">
We can prove that <span class="inlinecode"><span class="id" title="var">termination_leak</span></span> doesn't satisfy TSNI: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">tsni_insecure_termination_leak</span> :<br/>
&nbsp;&nbsp;¬<span class="id" title="var">tsni_while_R</span> <span class="id" title="var">ceval</span> <span class="id" title="var">xpub</span> <span class="id" title="var">termination_leak</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">tsni_while_R</span>, <span class="id" title="var">termination_leak</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">Hc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hc</span> (<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0 ; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0) (<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0 ; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 42; <span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0 ; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">xpub</span> <span class="id" title="var">x</span> = <span class="id" title="var">true</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0) <span class="id" title="var">x</span> = (<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 1) <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">clear</span> <span class="id" title="var">Hc</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">xpub_true</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hc</span> <span class="id" title="var">H</span>). <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">HH</span> : (<span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0) =[ <span class="id" title="var">termination_leak</span> ]=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 42; <span class="id" title="var">X</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0; <span class="id" title="var">Y</span> !<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span> 0)).<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">clear</span>. <span class="id" title="tactic">unfold</span> <span class="id" title="var">termination_leak</span>. <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hc</span> <span class="id" title="var">HH</span>). <span class="id" title="tactic">clear</span> <span class="id" title="var">HH</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Hc</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">s<sub>2</sub>'</span> [<span class="id" title="var">Hc</span> <span class="id" title="var">_</span>]].<br/>
&nbsp;&nbsp;<span class="id" title="var">invert</span> <span class="id" title="var">Hc</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H<sub>4</sub></span>. <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">loop_never_stops</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H<sub>5</sub></span>. <span class="id" title="var">contradiction</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
More generally, we can prove that TSNI is strictly stronger than TINI
    (noninterferent_while) 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">tsni_noninterferent</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">tsni_while_R</span> <span class="id" title="var">ceval</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent_while_R</span> <span class="id" title="var">ceval</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent_while_R</span>, <span class="id" title="var">tsni_while_R</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span> <span class="id" title="var">Htsni</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">Hequiv</span> <span class="id" title="var">H<sub>1</sub></span> <span class="id" title="var">H<sub>2</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Htsni</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">Hequiv</span> <span class="id" title="var">H<sub>1</sub></span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Htsni</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">s<sub>2</sub>''</span> [<span class="id" title="var">H<sub>2</sub>'</span> <span class="id" title="var">Hequiv'</span>]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">ceval_deterministic</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H<sub>2</sub></span> <span class="id" title="var">H<sub>2</sub>'</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Hequiv'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The reverse direction of the implication only works for programs that
    always terminate (such as most of our simple examples above). 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">terminating_noninterferent_tsni</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">s</span>, <span class="id" title="tactic">∃</span> <span class="id" title="var">s'</span>, <span class="id" title="var">s</span> =[ <span class="id" title="var">c</span> ]=&gt; <span class="id" title="var">s'</span>) →<br/>
&nbsp;&nbsp;<span class="id" title="var">noninterferent_while_R</span> <span class="id" title="var">ceval</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">tsni_while_R</span> <span class="id" title="var">ceval</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">noninterferent_while_R</span>, <span class="id" title="var">tsni_while_R</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span> <span class="id" title="var">Hterminating</span> <span class="id" title="var">Hni</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">s<sub>1</sub>'</span> <span class="id" title="var">Eq</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">Hterminating</span> <span class="id" title="var">s<sub>2</sub></span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">H'</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">s<sub>2</sub>'</span>; <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">Hni</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">s<sub>1</sub></span> := <span class="id" title="var">s<sub>1</sub></span>) (<span class="id" title="var">s<sub>2</sub></span> := <span class="id" title="var">s<sub>2</sub></span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Now for a more interesting use of TSNI: it turns out that
    <span class="inlinecode"><span class="id" title="var">sme_while</span></span> is transparent for programs satisfying TSNI. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">tsni_transparent_while_sme</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">tsni_while_R</span> <span class="id" title="var">ceval</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span> →<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">s</span> <span class="id" title="var">s'</span>, <span class="id" title="var">s</span> =[ <span class="id" title="var">c</span> ]=&gt; <span class="id" title="var">s'</span> ↔ (<span class="id" title="var">sme_while</span> <span class="id" title="var">pub</span>) <span class="id" title="var">c</span> <span class="id" title="var">s</span> <span class="id" title="var">s'</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">tsni_while_R</span>, <span class="id" title="var">sme_while</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">pub</span> <span class="id" title="var">c</span> <span class="id" title="var">Hni</span> <span class="id" title="var">s</span> <span class="id" title="var">s'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span>(<span class="id" title="var">HH</span>:<span class="id" title="var">pub_equiv</span> <span class="id" title="var">pub</span> <span class="id" title="var">s</span> (<span class="id" title="var">split_state</span> <span class="id" title="var">s</span> <span class="id" title="var">pub</span> <span class="id" title="var">true</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> <span class="id" title="var">pub_equiv_sym</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">pub_equiv_split_state</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hni</span> <span class="id" title="var">s</span> (<span class="id" title="var">split_state</span> <span class="id" title="var">s</span> <span class="id" title="var">pub</span> <span class="id" title="var">true</span>) <span class="id" title="var">s'</span> <span class="id" title="var">HH</span> <span class="id" title="var">H</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Hni</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">s''</span> [<span class="id" title="var">Heval</span> <span class="id" title="var">Hequiv</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <span class="id" title="var">s''</span>. <span class="id" title="tactic">∃</span> <span class="id" title="var">s'</span>. <span class="id" title="tactic">split</span>. <span class="id" title="tactic">assumption</span>. <span class="id" title="tactic">split</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">merge_state_pub_equiv</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">ps</span> [<span class="id" title="var">ss</span> [<span class="id" title="var">Hp</span> [<span class="id" title="var">Hs</span> <span class="id" title="var">Hm</span>]]]]. <span class="id" title="tactic">subst</span> <span class="id" title="var">s'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hni</span> <span class="id" title="var">s</span> (<span class="id" title="var">split_state</span> <span class="id" title="var">s</span> <span class="id" title="var">pub</span> <span class="id" title="var">true</span>) <span class="id" title="var">ss</span> <span class="id" title="var">HH</span> <span class="id" title="var">Hs</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Hni</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">s'</span> [<span class="id" title="var">Hp'</span> <span class="id" title="var">Hni</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">ceval_deterministic</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Hp</span> <span class="id" title="var">Hp'</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">merge_state_pub_equiv</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hni</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hni</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">Hs</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Unfortunately <span class="inlinecode"><span class="id" title="var">sme_while</span></span> does not imply TSNI, and this is hard to fix in
    our current setting, where programs only return a result in the end, a final
    state, so we had to merge the public and secret inputs into a single final
    state. Instead, SME is commonly defined in a setting with interactive IO, in
    which public outputs and secret outputs can be performed independently,
    during the execution. In that setting, it does transparently enforce TSNI. 
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>