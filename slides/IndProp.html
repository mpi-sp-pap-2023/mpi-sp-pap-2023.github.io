<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>IndProp: Inductively Defined Propositions</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="common/slides.js"></script>
<link href="common/css/slides.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 1: Logical Foundations</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
   <li class='section_name'><a href='deps.html'>Roadmap</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">IndProp<span class="subtitle">Inductively Defined Propositions</span></h1>



<div class="doc">
<a id="lab262"></a><h2 class="section">Please register for final exam by the end of this week!</h2>

<ul class="doclist">
<li> Final exam scheduled for August 3rd, 10:30 - 12:30 (2h)

</li>
<li> please officially register for this exam on FlexNow
          until Sunday, June 25th

</li>
<li> no longer wanted registrations can still be canceled
          until July 24th

</li>
<li> Re-exam scheduled for September 19th, 10:30 - 12:30 

</li>
</ul>
</div>

<div class="doc">
<a id="lab263"></a><h1 class="section">Inductively Defined Propositions</h1>

<div class="paragraph"> </div>

 In the <a href="Logic.html"><span class="inlineref">Logic</span></a> chapter, we looked at several ways of writing
    propositions, including conjunction, disjunction, and existential
    quantification.

<div class="paragraph"> </div>

    In this chapter, we bring yet another new tool into the mix:
    <i>inductively defined propositions</i>.

<div class="paragraph"> </div>

    To begin, some examples... 
</div>

<div class="doc">
<a id="lab264"></a><h2 class="section">The Collatz Conjecture</h2>

<div class="paragraph"> </div>

 The <i>Collatz Conjecture</i> is a famous open problem in number
    theory.

<div class="paragraph"> </div>

    Its statement is surprisingly simple.  First, we define a function
    <span class="inlinecode"><span class="id" title="var">f</span></span> on numbers, as follows: 
</div>
<div class="code">

<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">div2</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;0 ⇒ 0<br/>
&nbsp;&nbsp;| 1 ⇒ 0<br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) ⇒ <span class="id" title="var">S</span> (<span class="id" title="var">div2</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">even</span> <span class="id" title="var">n</span> <span class="id" title="keyword">then</span> <span class="id" title="var">div2</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> (3 × <span class="id" title="var">n</span>) + 1.<br/>
</div>

<div class="doc">
<a id="lab265"></a><h3 class="section"> </h3>
 Next, we look at what happens when we repeatedly apply <span class="inlinecode"><span class="id" title="var">f</span></span> to some
    given starting number.  For example, <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">12</span> is <span class="inlinecode">6</span>, and <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">6</span> is
    <span class="inlinecode">3</span>, so by repeatedly applying <span class="inlinecode"><span class="id" title="var">f</span></span> we get the sequence <span class="inlinecode">12,</span> <span class="inlinecode">6,</span> <span class="inlinecode">3,</span>
    <span class="inlinecode">10,</span> <span class="inlinecode">5,</span> <span class="inlinecode">16,</span> <span class="inlinecode">8,</span> <span class="inlinecode">4,</span> <span class="inlinecode">2,</span> <span class="inlinecode">1</span>.

<div class="paragraph"> </div>

    Similarly, if we start with <span class="inlinecode">19</span>, we get the longer sequence <span class="inlinecode">19,</span>
    <span class="inlinecode">58,</span> <span class="inlinecode">29,</span> <span class="inlinecode">88,</span> <span class="inlinecode">44,</span> <span class="inlinecode">22,</span> <span class="inlinecode">11,</span> <span class="inlinecode">34,</span> <span class="inlinecode">17,</span> <span class="inlinecode">52,</span> <span class="inlinecode">26,</span> <span class="inlinecode">13,</span> <span class="inlinecode">40,</span> <span class="inlinecode">20,</span> <span class="inlinecode">10,</span> <span class="inlinecode">5,</span> <span class="inlinecode">16,</span> <span class="inlinecode">8,</span>
    <span class="inlinecode">4,</span> <span class="inlinecode">2,</span> <span class="inlinecode">1</span>.

<div class="paragraph"> </div>

    Both of these sequences eventually reach <span class="inlinecode">1</span>.  The question posed
    by Collatz was: Does the sequence starting from <i>any</i> natural
    number eventually reach <span class="inlinecode">1</span>? 
<div class="paragraph"> </div>

<a id="lab266"></a><h3 class="section"> </h3>
 To formalize this question in Coq, we might try to define a
    recursive <i>function</i> that computes the total number of steps that
    it takes for such a sequence to reach <span class="inlinecode">1</span>. 
</div>
<div class="code">

<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">reaches1_in</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">n</span> =? 1 <span class="id" title="keyword">then</span> 0<br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> 1 + <span class="id" title="var">reaches1_in</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span>).<br/>
</div>

<div class="doc">
This definition is rejected by Coq's termination checker, since
    the argument to the recursive call, <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, is not "obviously
    smaller" than <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Indeed, this isn't just a silly limitation of the termination
    checker.  Functions in Coq are required to be total, and checking
    that this particular function is total would be equivalent to
    settling the Collatz conjecture! 
<div class="paragraph"> </div>

<a id="lab267"></a><h3 class="section"> </h3>
 Fortunately, there is another way to do it: We can express the
    concept "reaches <span class="inlinecode">1</span> eventually" as an <i>inductively defined
    property</i> of numbers <span class="inlinecode"><span class="id" title="var">reaches1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. Intuitively, this
    property is defined by a set of rules:

<div class="paragraph"> </div>

<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (reach_one) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">reaches1</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">Even n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reaches1 (div2 n)</td>
  <td class="infrulenamecol" rowspan="3">
    (reach_even) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">reaches1 n</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">~Even n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reaches1 ((3 * n) + 1)</td>
  <td class="infrulenamecol" rowspan="3">
    (reach_odd) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">reaches1 n</td>
  <td></td>
</tr>
</table></center>
<div class="paragraph"> </div>

    So there are three ways to prove that a number <span class="inlinecode"><span class="id" title="var">n</span></span> reaches 1 in
    the Collatz sequence:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">n</span></span> is 1;

</li>
<li> <span class="inlinecode"><span class="id" title="var">n</span></span> is even and <span class="inlinecode"><span class="id" title="var">div2</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> reaches 1;

</li>
<li> <span class="inlinecode"><span class="id" title="var">n</span></span> is odd and <span class="inlinecode">(3</span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> reaches 1.

</li>
</ul>
<a id="lab268"></a><h3 class="section"> </h3>
 We can prove that a number reaches 1 by constructing a (finite)
    derivation using these rules. For instance, here is the derivation
    proving that 12 reaches 1 (where we left out the evenness/oddness
    premises):
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——————————— (<span class="id" title="var">reach_one</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——————————— (<span class="id" title="var">reach_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——————————— (<span class="id" title="var">reach_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> 4<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——————————— (<span class="id" title="var">reach_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> 8<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——————————— (<span class="id" title="var">reach_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> 16<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——————————— (<span class="id" title="var">reach_odd</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> 5<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——————————— (<span class="id" title="var">reach_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> 10<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——————————— (<span class="id" title="var">reach_odd</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> 3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——————————— (<span class="id" title="var">reach_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> 6<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——————————— (<span class="id" title="var">reach_even</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> 12
</span><a id="lab269"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Formally in Coq, <span class="inlinecode"><span class="id" title="var">reaches1</span></span> is an <i>inductively defined property</i>
    of numbers: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">reaches1</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">reach_one</span> : <span class="id" title="var">reaches1</span> 1<br/>
&nbsp;&nbsp;| <span class="id" title="var">reach_even</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">Even</span> <span class="id" title="var">n</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> (<span class="id" title="var">div2</span> <span class="id" title="var">n</span>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">reach_odd</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : ¬<span class="id" title="var">Even</span> <span class="id" title="var">n</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> ((3 × <span class="id" title="var">n</span>) + 1) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">reaches1</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
The details of how such inductive definitions are written are not
    important and will be explained later. For the moment, note that
    the 3 constructors correspond exactly to the 3 rules above. 
<div class="paragraph"> </div>

<a id="lab270"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 The Collatz conjecture then states that the sequence beginning
    from <i>any</i> number reaches <span class="inlinecode">1</span>: 
</div>
<div class="code">

<span class="id" title="keyword">Conjecture</span> <span class="id" title="var">collatz</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">reaches1</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
If you succeed in proving this conjecture, you've got a bright
    future as a number theorist.  But don't spend too long on it --
    it's been open since 1937! 
</div>

<div class="doc">
<a id="lab271"></a><h2 class="section">Binary relations</h2>

<div class="paragraph"> </div>

 A binary <i>relation</i> on a set <span class="inlinecode"><span class="id" title="var">X</span></span> has Coq type <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.
    This is a family of propositions parameterized by two elements of
    <span class="inlinecode"><span class="id" title="var">X</span></span> -- i.e., a proposition about pairs of elements of <span class="inlinecode"><span class="id" title="var">X</span></span>. 
<div class="paragraph"> </div>

 For example, a familiar binary relation on <span class="inlinecode"><span class="id" title="var">nat</span></span> is <span class="inlinecode"><span class="id" title="var">le</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span>
    <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, the less-than-or-equal-to relation, which can be
    inductively defined by the following two rules: 
</div>

<div class="doc">
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (le_n) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">le n n</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">le n m</td>
  <td class="infrulenamecol" rowspan="3">
    (le_S) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">le n (S m)</td>
  <td></td>
</tr>
</table></center>
</div>

<div class="doc">
The Collatz step function <span class="inlinecode"><span class="id" title="var">f</span></span> also allows us to define a
    corresponding binary relation: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">collatz_step</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="keyword">Prop</span> := <span class="id" title="var">f</span> <span class="id" title="var">n</span> = <span class="id" title="var">m</span>.<br/>
</div>

<div class="doc">
This Collatz step relation is useful in conjunction with the
    reflexive and transitive closure operation below. 
</div>

<div class="doc">
<a id="lab272"></a><h2 class="section">Reflexive and Transitive Closure</h2>

<div class="paragraph"> </div>

 The <i>reflexive and transitive closure</i> of a relation <span class="inlinecode"><span class="id" title="var">R</span></span> is the
    smallest relation that contains <span class="inlinecode"><span class="id" title="var">R</span></span> and that is reflexive and
    transitive. This can be defined by the following three rules:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">R x y</td>
  <td class="infrulenamecol" rowspan="3">
    (rt_step) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">clos_refl_trans R x y</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (rt_refl) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">clos_refl_trans R x x</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">clos_refl_trans R x y&nbsp;&nbsp;&nbsp;&nbsp;clos_refl_trans R y z</td>
  <td class="infrulenamecol" rowspan="3">
    (rt_trans) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">clos_refl_trans R x z</td>
  <td></td>
</tr>
</table></center>
</div>

<div class="doc">
This enables an equivalent definition of the Collatz conjecture: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">cms</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> := <span class="id" title="var">clos_refl_trans</span> <span class="id" title="var">collatz_step</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Conjecture</span> <span class="id" title="var">collatz'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">cms</span> <span class="id" title="var">n</span> 1.<br/>
</div>

<div class="doc">
<a id="lab273"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 This <span class="inlinecode"><span class="id" title="var">cms</span></span> (Collatz multi-step) relation defined in terms of
    <span class="inlinecode"><span class="id" title="var">clos_refl_trans</span></span> allows for more interesting derivations than the
    linear ones of the directly defined <span class="inlinecode"><span class="id" title="var">reaches1</span></span> relation:
<br/>
<span class="inlinecode"><br/>
<span class="id" title="var">f</span> 16 = 8           <span class="id" title="var">f</span> 8 = 4           <span class="id" title="var">f</span> 4 = 2           <span class="id" title="var">f</span> 2 = 1<br/>
————————(<span class="id" title="var">rt_step</span>)  ———————(<span class="id" title="var">rt_step</span>)  ———————(<span class="id" title="var">rt_step</span>)  ———————(<span class="id" title="var">rt_step</span>)<br/>
<span class="id" title="var">cms</span> 16 8           <span class="id" title="var">cms</span> 8 4           <span class="id" title="var">cms</span> 4 2           <span class="id" title="var">cms</span> 2 1<br/>
—————————————————————————(<span class="id" title="var">rt_trans</span>)  ————————————————————————(<span class="id" title="var">rt_trans</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cms</span> 16 4                              <span class="id" title="var">cms</span> 4 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—————————————————————————————————————————————(<span class="id" title="var">rt_trans</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cms</span> 16 1
</span>
</div>

<div class="doc">
<a id="lab274"></a><h2 class="section">Permutations</h2>

<div class="paragraph"> </div>

 The familiar mathematical concept of <i>permutation</i> also has an
    elegant formulation as an inductive relation.  For simplicity,
    let's focus on permutations of lists with exactly three
    elements. We can define them by the following rules:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (perm3_swap12) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Perm3 [a;b;c] [b;a;c]</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (perm3_swap23) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Perm3 [a;b;c] [a;c;b]</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">Perm3 l<sub>1</sub> l<sub>2</sub>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perm3 l<sub>2</sub> l<sub>3</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (perm3_trans) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">Perm3 l<sub>1</sub> l<sub>3</sub></td>
  <td></td>
</tr>
</table></center>    For instance we can derive <span class="inlinecode"><span class="id" title="var">Perm3</span></span> <span class="inlinecode">[1;2;3]</span> <span class="inlinecode">[3;2;1]</span> as follows:
<br/>
<span class="inlinecode"><br/>
————————(<span class="id" title="var">perm_swap12</span>)  —————————————————————(<span class="id" title="var">perm_swap23</span>)<br/>
<span class="id" title="var">Perm3</span> [1;2;3] [2;1;3]  <span class="id" title="var">Perm3</span> [2;1;3] [2;3;1]<br/>
——————————————————————————————(<span class="id" title="var">perm_trans</span>)  ————————————(<span class="id" title="var">perm_swap12</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Perm3</span> [1;2;3] [2;3;1]                   <span class="id" title="var">Perm</span> [2;3;1] [3;2;1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;—————————————————————————————————————————————————————(<span class="id" title="var">perm_trans</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Perm3</span> [1;2;3] [3;2;1]
</span>
<div class="paragraph"> </div>

<a id="lab275"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 In Coq <span class="inlinecode"><span class="id" title="var">Perm3</span></span> is given the following inductive definition: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Perm3</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} : <span class="id" title="var">list</span> <span class="id" title="var">X</span> → <span class="id" title="var">list</span> <span class="id" title="var">X</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">perm3_swap12</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Perm3</span> [<span class="id" title="var">a</span>;<span class="id" title="var">b</span>;<span class="id" title="var">c</span>] [<span class="id" title="var">b</span>;<span class="id" title="var">a</span>;<span class="id" title="var">c</span>]<br/>
&nbsp;&nbsp;| <span class="id" title="var">perm3_swap23</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Perm3</span> [<span class="id" title="var">a</span>;<span class="id" title="var">b</span>;<span class="id" title="var">c</span>] [<span class="id" title="var">a</span>;<span class="id" title="var">c</span>;<span class="id" title="var">b</span>]<br/>
&nbsp;&nbsp;| <span class="id" title="var">perm3_trans</span> (<span class="id" title="var">l<sub>1</sub></span> <span class="id" title="var">l<sub>2</sub></span> <span class="id" title="var">l<sub>3</sub></span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Perm3</span> <span class="id" title="var">l<sub>1</sub></span> <span class="id" title="var">l<sub>2</sub></span> → <span class="id" title="var">Perm3</span> <span class="id" title="var">l<sub>2</sub></span> <span class="id" title="var">l<sub>3</sub></span> → <span class="id" title="var">Perm3</span> <span class="id" title="var">l<sub>1</sub></span> <span class="id" title="var">l<sub>3</sub></span>.<br/>
</div>

<div class="doc">
<a id="lab276"></a><h2 class="section">Evenness (yet again)</h2>

<div class="paragraph"> </div>

 We've already seen two ways of stating a proposition that a number
    <span class="inlinecode"><span class="id" title="var">n</span></span> is even: We can say

<div class="paragraph"> </div>

      (1) <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>, or

<div class="paragraph"> </div>

      (2) <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">k</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span>.

<div class="paragraph"> </div>

    A third possibility, which we'll use as a running example for
    some of this chapter, is to say that <span class="inlinecode"><span class="id" title="var">n</span></span> is even if we can
    <i>establish</i> its evenness from the following two rules:
<ul class="doclist">
<li> The number <span class="inlinecode">0</span> is even.

</li>
<li> If <span class="inlinecode"><span class="id" title="var">n</span></span> is even, then <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> is even. 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab277"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 To illustrate how this new definition of evenness works, let's
    imagine using it to show that <span class="inlinecode">4</span> is even. First, we give the
    rules names for easy reference:
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (ev_0) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">ev 0</td>
  <td></td>
</tr>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">ev n</td>
  <td class="infrulenamecol" rowspan="3">
    (ev_SS) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">ev (S (S n))</td>
  <td></td>
</tr>
</table></center>    Now we can use the following derivation to show <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">4</span>:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———— (<span class="id" title="var">ev_0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ev</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————— (<span class="id" title="var">ev_SS</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> 0))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;———————————————————— (<span class="id" title="var">ev_SS</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> 0))))
</span>
<div class="paragraph"> </div>

<a id="lab278"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 We can translate the informal definition of evenness from above
    into a formal <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> declaration, where each "way that a
    number can be even" corresponds to a separate constructor: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">ev</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">ev_0</span>                       : <span class="id" title="var">ev</span> 0<br/>
&nbsp;&nbsp;| <span class="id" title="var">ev_SS</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">ev</span> <span class="id" title="var">n</span>) : <span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>
</div>

<div class="doc">
We put off discussing syntax so far, but there are a few
    differences between inductive properties like <span class="inlinecode"><span class="id" title="var">ev</span></span> and inductive
    types like <span class="inlinecode"><span class="id" title="var">nat</span></span> or <span class="inlinecode"><span class="id" title="var">list</span></span>:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="var">list</span> (<span class="id" title="var">X</span>:<span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">cons</span> (<span class="id" title="var">x</span> : <span class="id" title="var">X</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>).
</span> 
<div class="paragraph"> </div>

 We can think of the inductive definition of <span class="inlinecode"><span class="id" title="var">ev</span></span> this as defining
    a Coq property <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, together with "evidence
    constructors" <span class="inlinecode"><span class="id" title="var">ev_0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">0</span> and
    <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span>. 
<div class="paragraph"> </div>

<a id="lab279"></a><h3 class="section"> </h3>
 These evidence constructors can be thought of as "primitive
    evidence of evenness", and they can be used just like proven
    theorems.  In particular, we can use Coq's <span class="inlinecode"><span class="id" title="tactic">apply</span></span> tactic with the
    constructor names to obtain evidence for <span class="inlinecode"><span class="id" title="var">ev</span></span> of particular
    numbers... 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_4</span> : <span class="id" title="var">ev</span> 4.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_0</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
... or we can use function application syntax to combine several
    constructors: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_4'</span> : <span class="id" title="var">ev</span> 4.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> (<span class="id" title="var">ev_SS</span> 2 (<span class="id" title="var">ev_SS</span> 0 <span class="id" title="var">ev_0</span>)). <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
In this way, we can also prove theorems that have hypotheses
    involving <span class="inlinecode"><span class="id" title="var">ev</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_plus4</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">ev</span> (4 + <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">Hn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">Hn</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab280"></a><h2 class="section">The Same for Permutations</h2>

<div class="paragraph"> </div>

 Similarly we can apply the evidence constructors to obtain
    evidence of <span class="inlinecode"><span class="id" title="var">Perm3</span></span> <span class="inlinecode">[1;2;3]</span> <span class="inlinecode">[3;2;1]</span>: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">perm_123_321</span> : <span class="id" title="var">Perm3</span> [1;2;3] [3;2;1].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">perm3_trans</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">l<sub>2</sub></span>:=[2;3;1]).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">perm3_trans</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">l<sub>2</sub></span>:=[2;1;3]).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">perm3_swap12</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">perm3_swap23</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">perm3_swap12</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab281"></a><h3 class="section"> </h3>
 And again we can use function application syntax to combine
    several constructors: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">perm_123_321'</span> : <span class="id" title="var">Perm3</span> [1;2;3] [3;2;1].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">perm3_trans</span> <span class="id" title="var">_</span> [2;3;1] <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">perm3_trans</span> <span class="id" title="var">_</span> [2;1;3] <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">perm3_swap12</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">perm3_swap23</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">perm3_swap12</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
So the informal derivation trees we drew above are not too far
    from what's happening formally.  Formally we're using the evidence
    constructors to build <i>evidence trees</i>, similar to the trees we
    built using the constructors of data types such as nat, list,
    binary trees storing numbers, etc. 
</div>

<div class="doc">
<a id="lab282"></a><h1 class="section">Using Evidence in Proofs</h1>

<div class="paragraph"> </div>

 Besides <i>constructing</i> evidence that numbers are even, we can also
    <i>destruct</i> such evidence, reasoning about how it could have been
    built.

<div class="paragraph"> </div>

    Introducing <span class="inlinecode"><span class="id" title="var">ev</span></span> with an <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> declaration tells Coq not
    only that the constructors <span class="inlinecode"><span class="id" title="var">ev_0</span></span> and <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> are valid ways to
    build evidence that some number is <span class="inlinecode"><span class="id" title="var">ev</span></span>, but also that these two
    constructors are the <i>only</i> ways to build evidence that numbers
    are <span class="inlinecode"><span class="id" title="var">ev</span></span>. 
<div class="paragraph"> </div>

<a id="lab283"></a><h3 class="section"> </h3>
 In other words, if someone gives us evidence <span class="inlinecode"><span class="id" title="var">E</span></span> for the proposition
    <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, then we know that <span class="inlinecode"><span class="id" title="var">E</span></span> must be one of two things:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">E</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">ev_0</span></span> and <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">O</span></span>, or

</li>
<li> <span class="inlinecode"><span class="id" title="var">E</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode"><span class="id" title="var">E'</span></span>, where <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span> and <span class="inlinecode"><span class="id" title="var">E'</span></span> is
        evidence for <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 This suggests that it should be possible to do <i>case
    analysis</i> and even <i>induction</i> on evidence of evenness... 
<div class="paragraph"> </div>

<a id="lab284"></a><h2 class="section">Destructing and Inverting Evidence</h2>

<div class="paragraph"> </div>

 We can prove our characterization of evidence for <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>,
    using <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_inversion</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ev</span> <span class="id" title="var">n</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> = 0) ∨ (<span class="id" title="tactic">∃</span> <span class="id" title="var">n'</span>, <span class="id" title="var">n</span> = <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) ∧ <span class="id" title="var">ev</span> <span class="id" title="var">n'</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n'</span> <span class="id" title="var">E'</span>] <span class="id" title="var">eqn</span>:<span class="id" title="var">EE</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;:&nbsp;ev&nbsp;0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'&nbsp;:&nbsp;ev&nbsp;(S&nbsp;(S&nbsp;n'))&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">∃</span> <span class="id" title="var">n'</span>. <span class="id" title="tactic">split</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">E'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Facts like this are often called "inversion lemmas" because they
    allow us to "invert" some given information to reason about all
    the different ways it could have been derived. 
</div>
<div class="quiz">


<div class="doc">
Which tactics are needed to prove this goal?
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">n</span> : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;<span class="id" title="var">E</span> : <span class="id" title="var">ev</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;<span class="id" title="var">F</span> : <span class="id" title="var">n</span> = 1<br/>
&nbsp;&nbsp;======================<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">false</span>
</span>
<div class="paragraph"> </div>

   (1) <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>

<div class="paragraph"> </div>

   (2) <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span>

<div class="paragraph"> </div>

   (3) both <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span>

<div class="paragraph"> </div>

   (4) These tactics are not sufficient to solve the goal. 
</div>
<div class="code">
<div class="togglescript" id="proofcontrol1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')"><span class="show"></span></div>
<div class="proofscript" id="proof1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">quiz_1_not_ev</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">n</span> = 1 → <span class="id" title="var">true</span> = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span> <span class="id" title="var">F</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span> <span class="id" title="var">E'</span>] <span class="id" title="var">eqn</span>:<span class="id" title="var">EE</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">discriminate</span> <span class="id" title="var">F</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">discriminate</span> <span class="id" title="var">F</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div></div> <!-- /quiz -->

<div class="doc">
<a id="lab285"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 We can use the inversion lemma that we proved above to help
    structure proofs: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">evSS_ev</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) → <span class="id" title="var">ev</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_inversion</span> <span class="id" title="keyword">in</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">H<sub>0</sub></span>|<span class="id" title="var">H<sub>1</sub></span>].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">discriminate</span> <span class="id" title="var">H<sub>0</sub></span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">H<sub>1</sub></span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n'</span> [<span class="id" title="var">Hnn'</span> <span class="id" title="var">E'</span>]]. <span class="id" title="tactic">injection</span> <span class="id" title="var">Hnn'</span> <span class="id" title="keyword">as</span> <span class="id" title="var">Hnn'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hnn'</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">E'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab286"></a><h3 class="section"> </h3>
 Coq provides a handy tactic called <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> that does
    the work of our inversion lemma and more besides. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">evSS_ev'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) → <span class="id" title="var">ev</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span> <span class="id" title="var">E'</span> <span class="id" title="var">Hnn'</span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;We&nbsp;are&nbsp;in&nbsp;the&nbsp;<span class="inlinecode"><span class="id" title="var">E</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode"><span class="id" title="var">E'</span></span>&nbsp;case&nbsp;now.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">E'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab287"></a><h3 class="section"> </h3>
 We can use <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> to re-prove some theorems from
    <span class="inlinecode"><span class="id" title="var">Tactics.v</span></span>.  (Note that <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> also works on equality
    propositions.) 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">inversion_ex<sub>1</sub></span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;[<span class="id" title="var">n</span>; <span class="id" title="var">m</span>] = [<span class="id" title="var">o</span>; <span class="id" title="var">o</span>] → [<span class="id" title="var">n</span>] = [<span class="id" title="var">m</span>].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">inversion_ex<sub>2</sub></span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">S</span> <span class="id" title="var">n</span> = <span class="id" title="var">O</span> → 2 + 2 = 5.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">contra</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">contra</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab288"></a><h3 class="section"> </h3>
 The tactic <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> actually works on any <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> where
    <span class="inlinecode"><span class="id" title="var">P</span></span> is defined <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>ly:

<div class="paragraph"> </div>

<ul class="doclist">
<li> For each constructor of <span class="inlinecode"><span class="id" title="var">P</span></span>, make a subgoal where <span class="inlinecode"><span class="id" title="var">H</span></span> is
        constrained by the form of this constructor.

<div class="paragraph"> </div>


</li>
<li> Discard contradictory subgoals (such as <span class="inlinecode"><span class="id" title="var">ev_0</span></span> above).

<div class="paragraph"> </div>


</li>
<li> Generate auxiliary equalities (as with <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> above). 

</li>
</ul>
</div>
<div class="quiz">


<div class="doc">
Which tactics are needed to prove this goal, in addition to
    <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> and <span class="inlinecode"><span class="id" title="tactic">apply</span></span>?
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">n</span> : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;<span class="id" title="var">E</span> : <span class="id" title="var">ev</span> (<span class="id" title="var">n</span> + 2)<br/>
&nbsp;&nbsp;=====================<br/>
&nbsp;&nbsp;<span class="id" title="var">ev</span> <span class="id" title="var">n</span>
</span>
<div class="paragraph"> </div>

   (1) <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>

<div class="paragraph"> </div>

   (2) <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span>

<div class="paragraph"> </div>

   (3) <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">add_comm</span></span>

<div class="paragraph"> </div>

   (4) <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">add_comm</span></span>, <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span>

<div class="paragraph"> </div>

   (5) These tactics are not sufficient to prove the goal.

<div class="paragraph"> </div>

 
</div>
<div class="code">
<div class="togglescript" id="proofcontrol2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')"><span class="show"></span></div>
<div class="proofscript" id="proof2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">quiz_ev_plus_2</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> (<span class="id" title="var">n</span> + 2) → <span class="id" title="var">ev</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">add_comm</span> <span class="id" title="keyword">in</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H<sub>0</sub></span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div></div> <!-- /quiz -->

<div class="doc">
<a id="lab289"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Let's try to show that our new notion of evenness implies
    our earlier notion (the one based on <span class="inlinecode"><span class="id" title="var">double</span></span>). 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ev_Even_firsttry</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">Even</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a id="lab290"></a><h2 class="section">Induction on Evidence</h2>

<div class="paragraph"> </div>

 If this story feels familiar, it is no coincidence: We've
    encountered similar problems in the <a href="Induction.html"><span class="inlineref">Induction</span></a> chapter, when
    trying to use case analysis to prove results that required
    induction.  And once again the solution is... induction! 
<div class="paragraph"> </div>

 Let's try proving that lemma again: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ev_Even</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">Even</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">Even</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">n'</span> <span class="id" title="var">E'</span> <span class="id" title="var">IH</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> 0. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E',&nbsp;&nbsp;with&nbsp;IH&nbsp;:&nbsp;Even&nbsp;n'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">IH</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">k</span> <span class="id" title="var">Hk</span>]. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hk</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> (<span class="id" title="var">S</span> <span class="id" title="var">k</span>). <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab291"></a><h1 class="section">Case Study: Regular Expressions</h1>

<div class="paragraph"> </div>

 Regular expressions are a simple language for describing sets of
    strings.  Their syntax is defined as follows: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">reg_exp</span> (<span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">EmptySet</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">EmptyStr</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Char</span> (<span class="id" title="var">t</span> : <span class="id" title="var">T</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">App</span> (<span class="id" title="var">r<sub>1</sub></span> <span class="id" title="var">r<sub>2</sub></span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">Union</span> (<span class="id" title="var">r<sub>1</sub></span> <span class="id" title="var">r<sub>2</sub></span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">Star</span> (<span class="id" title="var">r</span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>).<br/><hr class='doublespaceincode'/>
</div>

<div class="doc">
<a id="lab292"></a><h3 class="section"> </h3>
 We connect regular expressions and strings via the following
    rules, which define when a regular expression <i>matches</i> some
    string:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The expression <span class="inlinecode"><span class="id" title="var">EmptySet</span></span> does not match any string.

<div class="paragraph"> </div>


</li>
<li> The expression <span class="inlinecode"><span class="id" title="var">EmptyStr</span></span> matches the empty string <span class="inlinecode">[]</span>.

<div class="paragraph"> </div>


</li>
<li> The expression <span class="inlinecode"><span class="id" title="var">Char</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> matches the one-character string <span class="inlinecode">[<span class="id" title="var">x</span>]</span>.

<div class="paragraph"> </div>


</li>
<li> If <span class="inlinecode"><span class="id" title="var">re<sub>1</sub></span></span> matches <span class="inlinecode"><span class="id" title="var">s<sub>1</sub></span></span>, and <span class="inlinecode"><span class="id" title="var">re<sub>2</sub></span></span> matches <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span>,
        then <span class="inlinecode"><span class="id" title="var">App</span></span> <span class="inlinecode"><span class="id" title="var">re<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">re<sub>2</sub></span></span> matches <span class="inlinecode"><span class="id" title="var">s<sub>1</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span>.

<div class="paragraph"> </div>


</li>
<li> If at least one of <span class="inlinecode"><span class="id" title="var">re<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">re<sub>2</sub></span></span> matches <span class="inlinecode"><span class="id" title="var">s</span></span>,
        then <span class="inlinecode"><span class="id" title="var">Union</span></span> <span class="inlinecode"><span class="id" title="var">re<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">re<sub>2</sub></span></span> matches <span class="inlinecode"><span class="id" title="var">s</span></span>.

<div class="paragraph"> </div>


</li>
<li> Finally, if we can write some string <span class="inlinecode"><span class="id" title="var">s</span></span> as the concatenation
        of a sequence of strings <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">s_1</span></span> <span class="inlinecode">++</span> <span class="inlinecode">...</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">s_k</span></span>, and the
        expression <span class="inlinecode"><span class="id" title="var">re</span></span> matches each one of the strings <span class="inlinecode"><span class="id" title="var">s_i</span></span>,
        then <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span> matches <span class="inlinecode"><span class="id" title="var">s</span></span>.

<div class="paragraph"> </div>

        In particular, the sequence of strings may be empty, so
        <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span> always matches the empty string <span class="inlinecode">[]</span> no matter what
        <span class="inlinecode"><span class="id" title="var">re</span></span> is. 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab293"></a><h3 class="section"> </h3>
 We can easily translate this informal definition into an
    <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> one as follows.  We use the notation <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" title="var">re</span></span> in
    place of <span class="inlinecode"><span class="id" title="var">exp_match</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>.  (By "reserving" the notation before
    defining the <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>, we can use it in the definition.) 
</div>
<div class="code">

<span class="id" title="keyword">Reserved Notation</span> &quot;s =~ re" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 80).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">exp_match</span> {<span class="id" title="var">T</span>} : <span class="id" title="var">list</span> <span class="id" title="var">T</span> → <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">MEmpty</span> : [] =~ <span class="id" title="var">EmptyStr</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">MChar</span> <span class="id" title="var">x</span> : [<span class="id" title="var">x</span>] =~ (<span class="id" title="var">Char</span> <span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">MApp</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H<sub>1</sub></span> : <span class="id" title="var">s<sub>1</sub></span> =~ <span class="id" title="var">re<sub>1</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H<sub>2</sub></span> : <span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">re<sub>2</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: (<span class="id" title="var">s<sub>1</sub></span> ++ <span class="id" title="var">s<sub>2</sub></span>) =~ (<span class="id" title="var">App</span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">re<sub>2</sub></span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">MUnionL</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H<sub>1</sub></span> : <span class="id" title="var">s<sub>1</sub></span> =~ <span class="id" title="var">re<sub>1</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">s<sub>1</sub></span> =~ (<span class="id" title="var">Union</span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">re<sub>2</sub></span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">MUnionR</span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H<sub>2</sub></span> : <span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">re<sub>2</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">s<sub>2</sub></span> =~ (<span class="id" title="var">Union</span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">re<sub>2</sub></span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">MStar0</span> <span class="id" title="var">re</span> : [] =~ (<span class="id" title="var">Star</span> <span class="id" title="var">re</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">MStarApp</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">re</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H<sub>1</sub></span> : <span class="id" title="var">s<sub>1</sub></span> =~ <span class="id" title="var">re</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H<sub>2</sub></span> : <span class="id" title="var">s<sub>2</sub></span> =~ (<span class="id" title="var">Star</span> <span class="id" title="var">re</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: (<span class="id" title="var">s<sub>1</sub></span> ++ <span class="id" title="var">s<sub>2</sub></span>) =~ (<span class="id" title="var">Star</span> <span class="id" title="var">re</span>)<br/>
<br/>
&nbsp;&nbsp;<span class="id" title="keyword">where</span> &quot;s =~ re" := (<span class="id" title="var">exp_match</span> <span class="id" title="var">s</span> <span class="id" title="var">re</span>).<br/><hr class='doublespaceincode'/>
 <!-- /quiz -->
</div><div class="quiz">


<div class="doc">
Notice that this clause in our informal definition...

<div class="paragraph"> </div>

<ul class="doclist">
<li> "The expression <span class="inlinecode"><span class="id" title="var">EmptySet</span></span> does not match any string."

</li>
</ul>

<div class="paragraph"> </div>

    ... is not explicitly reflected in the above definition.  Do we
    need to add something?

<div class="paragraph"> </div>

   (1) Yes, we should add a rule for this.

<div class="paragraph"> </div>

   (2) No, one of the other rules already covers this case.

<div class="paragraph"> </div>

   (3) No, the <i>lack</i> of a rule actually gives us the behavior we
       want.

<div class="paragraph"> </div>


</div>
</div> <!-- /quiz -->

<div class="doc">
<a id="lab294"></a><h3 class="section"> </h3>

</div>
<div class="code">
<span class="id" title="keyword">Example</span> <span class="id" title="var">reg_exp_ex<sub>1</sub></span> : [1] =~ <span class="id" title="var">Char</span> 1.<br/>
<div class="togglescript" id="proofcontrol3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')"><span class="show"></span></div>
<div class="proofscript" id="proof3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">MChar</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">reg_exp_ex<sub>2</sub></span> : [1; 2] =~ <span class="id" title="var">App</span> (<span class="id" title="var">Char</span> 1) (<span class="id" title="var">Char</span> 2).<br/>
<div class="togglescript" id="proofcontrol4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')"><span class="show"></span></div>
<div class="proofscript" id="proof4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">MApp</span> [1]).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">MChar</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">MChar</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">reg_exp_ex<sub>3</sub></span> : ¬([1; 2] =~ <span class="id" title="var">Char</span> 1).<br/>
<div class="togglescript" id="proofcontrol5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')"><span class="show"></span></div>
<div class="proofscript" id="proof5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
<a id="lab295"></a><h3 class="section"> </h3>
 Something more interesting: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">MStar1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">T</span> <span class="id" title="var">s</span> (<span class="id" title="var">re</span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>) ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">s</span> =~ <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">s</span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span>.<br/>
<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a id="lab296"></a><h2 class="section">The <span class="inlinecode"><span class="id" title="var">remember</span></span> Tactic</h2>

<div class="paragraph"> </div>

 One potentially confusing feature of the <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic is
    that it will let you try to perform an induction over a term that
    isn't sufficiently general.  The effect of this is to lose
    information (much as <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> without an <span class="inlinecode"><span class="id" title="var">eqn</span>:</span> clause can do),
    and leave you unable to complete the proof.  Here's an example: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">star_app</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">T</span> (<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span>) (<span class="id" title="var">re</span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> ++ <span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">T</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">re</span> <span class="id" title="var">H<sub>1</sub></span>.<br/>
</div>

<div class="doc">
A naive first attempt at setting up the induction.  (Note
    that we are performing induction on evidence!)  (We can begin by generalizing <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span>, since it's pretty clear that we
    are going to have to walk over both <span class="inlinecode"><span class="id" title="var">s<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span> in parallel.) 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">s<sub>2</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H<sub>1</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">as</span> [|<span class="id" title="var">x'</span>|<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">re<sub>2</sub></span> <span class="id" title="var">Hmatch1</span> <span class="id" title="var">IH<sub>1</sub></span> <span class="id" title="var">Hmatch2</span> <span class="id" title="var">IH<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">re<sub>2</sub></span> <span class="id" title="var">Hmatch</span> <span class="id" title="var">IH</span>|<span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">re<sub>2</sub></span> <span class="id" title="var">Hmatch</span> <span class="id" title="var">IH</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" title="var">re''</span>|<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">re''</span> <span class="id" title="var">Hmatch1</span> <span class="id" title="var">IH<sub>1</sub></span> <span class="id" title="var">Hmatch2</span> <span class="id" title="var">IH<sub>2</sub></span>].<br/>
</div>

<div class="doc">
<a id="lab297"></a><h3 class="section"> </h3>
 We can get through the first case... 
</div>
<div class="code">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MEmpty&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
</div>

<div class="doc">
... but most cases get stuck.  For <span class="inlinecode"><span class="id" title="var">MChar</span></span>, for instance, we
    must show
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">s<sub>2</sub></span>     =~ <span class="id" title="var">Char</span> <span class="id" title="var">x'</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">x'</span>::<span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Char</span> <span class="id" title="var">x'</span>
</span>    which is clearly impossible. 
</div>
<div class="code">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MChar.&nbsp;*)</span> <span class="id" title="tactic">intros</span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">H</span>. <span class="id" title="tactic">simpl</span>. <span class="comment">(*&nbsp;Stuck...&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
<a id="lab298"></a><h3 class="section"> </h3>
 The problem here is that <span class="inlinecode"><span class="id" title="tactic">induction</span></span> over a Prop hypothesis
    only works properly with hypotheses that are "completely
    general," i.e., ones in which all the arguments are variables,
    as opposed to more complex expressions like <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>.

<div class="paragraph"> </div>

    A possible, but awkward, way to solve this problem is "manually
    generalizing" over the problematic expressions by adding
    explicit equality hypotheses to the lemma: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">star_app</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">T</span> (<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span>) (<span class="id" title="var">re</span> <span class="id" title="var">re'</span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">re'</span> = <span class="id" title="var">Star</span> <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> =~ <span class="id" title="var">re'</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> ++ <span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span>.<br/>
</div>

<div class="doc">
This works, but it makes the statement of the lemma a bit ugly.
    Fortunately, there is a better way... 
</div>
<div class="code">
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
<a id="lab299"></a><h3 class="section"> </h3>
 The tactic <span class="inlinecode"><span class="id" title="var">remember</span></span> <span class="inlinecode"><span class="id" title="var">e</span></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">eqn</span>:<span class="id" title="var">Eq</span></span> causes Coq to (1) replace all
    occurrences of the expression <span class="inlinecode"><span class="id" title="var">e</span></span> by the variable <span class="inlinecode"><span class="id" title="var">x</span></span>, and (2) add
    an equation <span class="inlinecode"><span class="id" title="var">Eq</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">e</span></span> to the context.  Here's how we can use it
    to show the above result: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">star_app</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">T</span> (<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span>) (<span class="id" title="var">re</span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> ++ <span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">T</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">re</span> <span class="id" title="var">H<sub>1</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">Star</span> <span class="id" title="var">re</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">re'</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">Eq</span>.<br/>
</div>

<div class="doc">
We now have <span class="inlinecode"><span class="id" title="var">Eq</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">re'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>. 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">s<sub>2</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H<sub>1</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">as</span> [|<span class="id" title="var">x'</span>|<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">re<sub>2</sub></span> <span class="id" title="var">Hmatch1</span> <span class="id" title="var">IH<sub>1</sub></span> <span class="id" title="var">Hmatch2</span> <span class="id" title="var">IH<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">re<sub>2</sub></span> <span class="id" title="var">Hmatch</span> <span class="id" title="var">IH</span>|<span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">re<sub>2</sub></span> <span class="id" title="var">Hmatch</span> <span class="id" title="var">IH</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" title="var">re''</span>|<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">re''</span> <span class="id" title="var">Hmatch1</span> <span class="id" title="var">IH<sub>1</sub></span> <span class="id" title="var">Hmatch2</span> <span class="id" title="var">IH<sub>2</sub></span>].<br/>
</div>

<div class="doc">
<a id="lab300"></a><h3 class="section"> </h3>
 The <span class="inlinecode"><span class="id" title="var">Eq</span></span> is contradictory in most cases, allowing us to
    conclude immediately. 
</div>
<div class="code">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MEmpty&nbsp;*)</span>  <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MChar&nbsp;*)</span>   <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MApp&nbsp;*)</span>    <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MUnionL&nbsp;*)</span> <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MUnionR&nbsp;*)</span> <span class="id" title="tactic">discriminate</span>.<br/>
</div>

<div class="doc">
The interesting cases are those that correspond to <span class="inlinecode"><span class="id" title="var">Star</span></span>. 
</div>
<div class="code">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MStar0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">s</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MStarApp&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">injection</span> <span class="id" title="var">Eq</span> <span class="id" title="keyword">as</span> <span class="id" title="var">Eq'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">H<sub>1</sub></span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">app_assoc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">MStarApp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">Hmatch1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">IH<sub>2</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Eq'</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">apply</span> <span class="id" title="var">H<sub>1</sub></span>.<br/>
</div>

<div class="doc">
Note that the induction hypothesis <span class="inlinecode"><span class="id" title="var">IH<sub>2</sub></span></span> on the <span class="inlinecode"><span class="id" title="var">MStarApp</span></span> case
    mentions an additional premise <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re''</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>, which
    results from the equality generated by <span class="inlinecode"><span class="id" title="var">remember</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab301"></a><h1 class="section">Case Study: Improving Reflection</h1>

<div class="paragraph"> </div>

 We've seen that we often need to relate boolean
    computations to statements in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.  However, this can
    result in some tedium in proof scripts.

<div class="paragraph"> </div>

    Consider: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">filter_not_empty_In</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">filter</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">n</span> =? <span class="id" title="var">x</span>) <span class="id" title="var">l</span> ≠ [] →<br/>
&nbsp;&nbsp;<span class="id" title="var">In</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">m</span> <span class="id" title="var">l'</span> <span class="id" title="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;<span class="inlinecode"></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">n</span> =? <span class="id" title="var">m</span>) <span class="id" title="var">eqn</span>:<span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;=?&nbsp;m&nbsp;=&nbsp;true&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">_</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">eqb_eq</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;=?&nbsp;m&nbsp;=&nbsp;false&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHl'</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The first subcase (where <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>) is awkward
    because we have to explicitly "switch worlds."

<div class="paragraph"> </div>

    It would be annoying to have to do this kind of thing all the
    time. 
<div class="paragraph"> </div>

<a id="lab302"></a><h3 class="section"> </h3>
 We can streamline this sort of reasoning by defining an inductive
    proposition that yields a better case-analysis principle for <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span>
    <span class="inlinecode"><span class="id" title="var">m</span></span>.  Instead of generating the assumption <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>, which
    usually requires some massaging before we can use it, this
    principle gives us right away the assumption we really need: <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" title="var">m</span></span>.

<div class="paragraph"> </div>

    Following the terminology introduced in <a href="Logic.html"><span class="inlineref">Logic</span></a>, we call this
    the "reflection principle for equality on numbers," and we say
    that the boolean <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span> is <i>reflected in</i> the proposition <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">reflect</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="var">bool</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">ReflectT</span> (<span class="id" title="var">H</span> :   <span class="id" title="var">P</span>) : <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">ReflectF</span> (<span class="id" title="var">H</span> : ¬<span class="id" title="var">P</span>) : <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> <span class="id" title="var">false</span>.<br/>
</div>

<div class="doc">
Notice that the only way to produce evidence for <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span>
    <span class="inlinecode"><span class="id" title="var">true</span></span> is by showing <span class="inlinecode"><span class="id" title="var">P</span></span> and then using the <span class="inlinecode"><span class="id" title="var">ReflectT</span></span> constructor.

<div class="paragraph"> </div>

    If we play this reasoning backwards, it says we can extract
    <i>evidence</i> for <span class="inlinecode"><span class="id" title="var">P</span></span> from evidence for <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

 To put this observation to work, we first prove that the
    statements <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">↔</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> are indeed
    equivalent.  First, the left-to-right implication: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">iff_reflect</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">b</span>, (<span class="id" title="var">P</span> ↔ <span class="id" title="var">b</span> = <span class="id" title="var">true</span>) → <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
(The right-to-left implication is left as an exercise.) 
<div class="paragraph"> </div>

<a id="lab303"></a><h3 class="section"> </h3>
 We can think of <span class="inlinecode"><span class="id" title="var">reflect</span></span> as a kind of variant of the usual "if
    and only if" connective; the advantage of <span class="inlinecode"><span class="id" title="var">reflect</span></span> is that, by
    destructing a hypothesis or lemma of the form <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>, we
    can perform case analysis on <span class="inlinecode"><span class="id" title="var">b</span></span> while <i>at the same time</i>
    generating appropriate hypothesis in the two branches (<span class="inlinecode"><span class="id" title="var">P</span></span> in the
    first subgoal and <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" title="var">P</span></span> in the second). 
<div class="paragraph"> </div>

<a id="lab304"></a><h3 class="section"> </h3>
 Let's use <span class="inlinecode"><span class="id" title="var">reflect</span></span> to produce a smoother proof of
    <span class="inlinecode"><span class="id" title="var">filter_not_empty_In</span></span>.

<div class="paragraph"> </div>

    We begin by recasting the <span class="inlinecode"><span class="id" title="var">eqb_eq</span></span> lemma in terms of <span class="inlinecode"><span class="id" title="var">reflect</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">eqbP</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, <span class="id" title="var">reflect</span> (<span class="id" title="var">n</span> = <span class="id" title="var">m</span>) (<span class="id" title="var">n</span> =? <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">iff_reflect</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">eqb_eq</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab305"></a><h3 class="section"> </h3>
 The proof of <span class="inlinecode"><span class="id" title="var">filter_not_empty_In</span></span> now goes as follows.  Notice
    how the calls to <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> in the earlier proof of
    this theorem are combined here into a single call to
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">filter_not_empty_In'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">filter</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">n</span> =? <span class="id" title="var">x</span>) <span class="id" title="var">l</span> ≠ [] →<br/>
&nbsp;&nbsp;<span class="id" title="var">In</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">m</span> <span class="id" title="var">l'</span> <span class="id" title="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;<span class="inlinecode"></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">eqbP</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">H</span> | <span class="id" title="var">H</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;=&nbsp;m&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">_</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;&lt;&gt;&nbsp;m&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHl'</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab306"></a><h3 class="section"> </h3>
 This small example shows reflection giving us a small gain in
    convenience; in larger developments, using <span class="inlinecode"><span class="id" title="var">reflect</span></span> consistently
    can often lead to noticeably shorter and clearer proof scripts.
    We'll see many more examples in later chapters and in <i>Programming
    Language Foundations</i>.

<div class="paragraph"> </div>

    This use of <span class="inlinecode"><span class="id" title="var">reflect</span></span> was popularized by <i>SSReflect</i>, a Coq
    library that has been used to formalize important results in
    mathematics, including the 4-color theorem and the Feit-Thompson
    theorem.  The name SSReflect stands for <i>small-scale reflection</i>,
    i.e., the pervasive use of reflection to simplify small proof
    steps by turning them into boolean computations. 
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>