<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>IndProp: Inductively Defined Propositions</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="common/slides.js"></script>
<link href="common/css/slides.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 1: Logical Foundations</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
   <li class='section_name'><a href='deps.html'>Roadmap</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">IndProp<span class="subtitle">Inductively Defined Propositions</span></h1>



<div class="doc">
<a id="lab260"></a><h1 class="section">Inductively Defined Propositions</h1>

<div class="paragraph"> </div>

 In the <a href="Logic.html"><span class="inlineref">Logic</span></a> chapter, we looked at several ways of writing
    propositions, including conjunction, disjunction, and existential
    quantification.

<div class="paragraph"> </div>

    In this chapter, we bring yet another new tool into the mix:
    <i>inductively defined propositions</i>.

<div class="paragraph"> </div>

    To begin, some examples... 
</div>

<div class="doc">
<a id="lab261"></a><h2 class="section">The Collatz Conjecture</h2>

<div class="paragraph"> </div>

 The <i>Collatz Conjecture</i> is a famous open problem in number
    theory.

<div class="paragraph"> </div>

    Its statement is surprisingly simple.  First, we define a function
    <span class="inlinecode"><span class="id" title="var">f</span></span> on numbers, as follows: 
</div>
<div class="code">

<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">div2</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;0 ⇒ 0<br/>
&nbsp;&nbsp;| 1 ⇒ 0<br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) ⇒ <span class="id" title="var">S</span> (<span class="id" title="var">div2</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">even</span> <span class="id" title="var">n</span> <span class="id" title="keyword">then</span> <span class="id" title="var">div2</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> (3 × <span class="id" title="var">n</span>) + 1.<br/>
</div>

<div class="doc">
Next, we look at what happens when we repeatedly apply <span class="inlinecode"><span class="id" title="var">f</span></span> to some
    given starting number.  For example, <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">12</span> is <span class="inlinecode">6</span>, and <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">6</span> is
    <span class="inlinecode">3</span>, so by repeatedly applying <span class="inlinecode"><span class="id" title="var">f</span></span> we get the sequence <span class="inlinecode">12,</span> <span class="inlinecode">6,</span> <span class="inlinecode">3,</span>
    <span class="inlinecode">10,</span> <span class="inlinecode">5,</span> <span class="inlinecode">16,</span> <span class="inlinecode">8,</span> <span class="inlinecode">4,</span> <span class="inlinecode">2,</span> <span class="inlinecode">1</span>.

<div class="paragraph"> </div>

    Similarly, if we start with <span class="inlinecode">19</span>, we get the longer sequence <span class="inlinecode">19,</span>
    <span class="inlinecode">58,</span> <span class="inlinecode">29,</span> <span class="inlinecode">88,</span> <span class="inlinecode">44,</span> <span class="inlinecode">22,</span> <span class="inlinecode">11,</span> <span class="inlinecode">34,</span> <span class="inlinecode">17,</span> <span class="inlinecode">52,</span> <span class="inlinecode">26,</span> <span class="inlinecode">13,</span> <span class="inlinecode">40,</span> <span class="inlinecode">20,</span> <span class="inlinecode">10,</span> <span class="inlinecode">5,</span> <span class="inlinecode">16,</span> <span class="inlinecode">8,</span>
    <span class="inlinecode">4,</span> <span class="inlinecode">2,</span> <span class="inlinecode">1</span>.

<div class="paragraph"> </div>

    Both of these sequences eventually reach <span class="inlinecode">1</span>.  The question posed
    by Collatz was: Does the sequence starting from <i>any</i> natural
    number eventually reach <span class="inlinecode">1</span>? 
<div class="paragraph"> </div>

 To formalize this question in Coq, we might try to define a
    recursive <i>function</i> that computes the total number of steps that
    it takes for such a sequence to reach <span class="inlinecode">1</span>. 
</div>
<div class="code">

<span class="id" title="var">Fail</span> <span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">reaches_1_in</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">n</span> =? 1 <span class="id" title="keyword">then</span> 0<br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> 1 + <span class="id" title="var">reaches_1_in</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span>).<br/>
</div>

<div class="doc">
This definition is rejected by Coq's termination checker, since
    the argument to the recursive call, <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, is not "obviously
    smaller" than <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

    Indeed, this isn't just a silly limitation of the termination
    checker.  Functions in Coq are required to be total, and checking
    that this particular function is total would be equivalent to
    settling the Collatz conjecture! 
<div class="paragraph"> </div>

 Fortunately, there is another way to do it: We can express the
    concept "reaches <span class="inlinecode">1</span> eventually" as an <i>inductively defined
    property</i> of numbers: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">reaches_1</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">term_done</span> : <span class="id" title="var">reaches_1</span> 1<br/>
&nbsp;&nbsp;| <span class="id" title="var">term_more</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">reaches_1</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span>) → <span class="id" title="var">reaches_1</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
The details of such definitions are written will be explained
    below; for the moment, the way to read this one is: "The number
    <span class="inlinecode">1</span> reaches <span class="inlinecode">1</span>, and any number <span class="inlinecode"><span class="id" title="var">n</span></span> reaches <span class="inlinecode">1</span> if <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> does." 
<div class="paragraph"> </div>

 The Collatz conjecture then states that the sequence beginning
    from <i>any</i> number reaches <span class="inlinecode">1</span>: 
</div>
<div class="code">

<span class="id" title="keyword">Conjecture</span> <span class="id" title="var">collatz</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">reaches_1</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
If you succeed in proving this conjecture, you've got a bright
    future as a number theorist.  But don't spend too long on it --
    it's been open since 1937! 
</div>

<div class="doc">
<a id="lab262"></a><h2 class="section">Transitive Closure</h2>

<div class="paragraph"> </div>

 A binary <i>relation</i> on a set <span class="inlinecode"><span class="id" title="var">X</span></span> is a family of propositions
    parameterized by two elements of <span class="inlinecode"><span class="id" title="var">X</span></span> -- i.e., a proposition about
    pairs of elements of <span class="inlinecode"><span class="id" title="var">X</span></span>.  
<div class="paragraph"> </div>

 For example, a familiar binary relation on <span class="inlinecode"><span class="id" title="var">nat</span></span> is <span class="inlinecode"><span class="id" title="var">le</span></span>, the
    less-than-or-equal-to relation. 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <span class="id" title="var">LePlayground</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">le</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">le_n</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)   : <span class="id" title="var">le</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">le_S</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">le</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> → <span class="id" title="var">le</span> <span class="id" title="var">n</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">End</span> <span class="id" title="var">LePlayground</span>.<br/>
</div>

<div class="doc">
The <i>transitive closure</i> of a relation <span class="inlinecode"><span class="id" title="var">R</span></span> is the smallest
    relation that contains <span class="inlinecode"><span class="id" title="var">R</span></span> and that is transitive.  
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">clos_trans</span> {<span class="id" title="var">X</span>: <span class="id" title="keyword">Type</span>} (<span class="id" title="var">R</span>: <span class="id" title="var">X</span>→<span class="id" title="var">X</span>→<span class="id" title="keyword">Prop</span>) : <span class="id" title="var">X</span>→<span class="id" title="var">X</span>→<span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">t_step</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">clos_trans</span> <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">t_trans</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">clos_trans</span> <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">clos_trans</span> <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">clos_trans</span> <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">z</span>.<br/>
</div>

<div class="doc">
<a id="lab263"></a><h2 class="section">Permutations</h2>

<div class="paragraph"> </div>

 The familiar mathematical concept of <i>permutation</i> also has an
    elegant formulation as an inductive relation.  For simplicity,
    let's focus on permutations of lists with exactly three
    elements. 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Perm3</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} : <span class="id" title="var">list</span> <span class="id" title="var">X</span> → <span class="id" title="var">list</span> <span class="id" title="var">X</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">perm3_swap12</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Perm3</span> [<span class="id" title="var">a</span>;<span class="id" title="var">b</span>;<span class="id" title="var">c</span>] [<span class="id" title="var">b</span>;<span class="id" title="var">a</span>;<span class="id" title="var">c</span>]<br/>
&nbsp;&nbsp;| <span class="id" title="var">perm3_swap23</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> : <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Perm3</span> [<span class="id" title="var">a</span>;<span class="id" title="var">b</span>;<span class="id" title="var">c</span>] [<span class="id" title="var">a</span>;<span class="id" title="var">c</span>;<span class="id" title="var">b</span>]<br/>
&nbsp;&nbsp;| <span class="id" title="var">perm3_trans</span> (<span class="id" title="var">l<sub>1</sub></span> <span class="id" title="var">l<sub>2</sub></span> <span class="id" title="var">l<sub>3</sub></span> : <span class="id" title="var">list</span> <span class="id" title="var">X</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Perm3</span> <span class="id" title="var">l<sub>1</sub></span> <span class="id" title="var">l<sub>2</sub></span> → <span class="id" title="var">Perm3</span> <span class="id" title="var">l<sub>2</sub></span> <span class="id" title="var">l<sub>3</sub></span> → <span class="id" title="var">Perm3</span> <span class="id" title="var">l<sub>1</sub></span> <span class="id" title="var">l<sub>3</sub></span>.<br/>
</div>

<div class="doc">
This definition says:
<ul class="doclist">
<li> If <span class="inlinecode"><span class="id" title="var">l<sub>2</sub></span></span> can be obtained from <span class="inlinecode"><span class="id" title="var">l<sub>1</sub></span></span> by swapping the first and
        second elements, then <span class="inlinecode"><span class="id" title="var">l<sub>2</sub></span></span> is a permutation of <span class="inlinecode"><span class="id" title="var">l<sub>1</sub></span></span>.

</li>
<li> If <span class="inlinecode"><span class="id" title="var">l<sub>2</sub></span></span> can be obtained from <span class="inlinecode"><span class="id" title="var">l<sub>1</sub></span></span> by swapping the second and
        third elements, then <span class="inlinecode"><span class="id" title="var">l<sub>2</sub></span></span> is a permutation of <span class="inlinecode"><span class="id" title="var">l<sub>1</sub></span></span>.

</li>
<li> If <span class="inlinecode"><span class="id" title="var">l<sub>2</sub></span></span> is a permutation of <span class="inlinecode"><span class="id" title="var">l<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">l<sub>3</sub></span></span> is a permutation of
        <span class="inlinecode"><span class="id" title="var">l<sub>2</sub></span></span>, then <span class="inlinecode"><span class="id" title="var">l<sub>3</sub></span></span> is a permutation of <span class="inlinecode"><span class="id" title="var">l<sub>1</sub></span></span>. 

</li>
</ul>
</div>

<div class="doc">
<a id="lab264"></a><h2 class="section">Evenness (yet again)</h2>

<div class="paragraph"> </div>

<a id="lab265"></a><h3 class="section"> </h3>
 We've already seen two ways of stating a proposition that a number
    <span class="inlinecode"><span class="id" title="var">n</span></span> is even: We can say

<div class="paragraph"> </div>

      (1) <span class="inlinecode"><span class="id" title="var">even</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>, or

<div class="paragraph"> </div>

      (2) <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">k</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">double</span></span> <span class="inlinecode"><span class="id" title="var">k</span></span>.

<div class="paragraph"> </div>

    A third possibility, which we'll use as a running example for the
    rest of this chapter, is to say that <span class="inlinecode"><span class="id" title="var">n</span></span> is even if we can
    <i>establish</i> its evenness from the following rules:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The number <span class="inlinecode">0</span> is even.

</li>
<li> If <span class="inlinecode"><span class="id" title="var">n</span></span> is even, then <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> is even. 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab266"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 We can translate the informal definition of evenness from above
    into a formal <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> declaration, where each "way that a
    number can be even" corresponds to a separate constructor: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">ev</span> : <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">ev_0</span>                       : <span class="id" title="var">ev</span> 0<br/>
&nbsp;&nbsp;| <span class="id" title="var">ev_SS</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">ev</span> <span class="id" title="var">n</span>) : <span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>
</div>

<div class="doc">
We can think of this as defining a Coq property <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span>
    <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, together with "evidence constructors" <span class="inlinecode"><span class="id" title="var">ev_0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">0</span> and
    <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span>,</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span>. 
<div class="paragraph"> </div>

<a id="lab267"></a><h3 class="section"> </h3>
 These evidence constructors can be thought of as "primitive
    evidence of evenness", and they can be used just like proven
    theorems.  In particular, we can use Coq's <span class="inlinecode"><span class="id" title="tactic">apply</span></span> tactic with the
    constructor names to obtain evidence for <span class="inlinecode"><span class="id" title="var">ev</span></span> of particular
    numbers... 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_4</span> : <span class="id" title="var">ev</span> 4.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_0</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
... or we can use function application syntax to combine several
    constructors: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_4'</span> : <span class="id" title="var">ev</span> 4.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">apply</span> (<span class="id" title="var">ev_SS</span> 2 (<span class="id" title="var">ev_SS</span> 0 <span class="id" title="var">ev_0</span>)). <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
In this way, we can also prove theorems that have hypotheses
    involving <span class="inlinecode"><span class="id" title="var">ev</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_plus4</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">ev</span> (4 + <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">Hn</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_SS</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">Hn</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab268"></a><h1 class="section">Using Evidence in Proofs</h1>

<div class="paragraph"> </div>

 Besides <i>constructing</i> evidence that numbers are even, we can also
    <i>destruct</i> such evidence, reasoning about how it could have been
    built.

<div class="paragraph"> </div>

    Introducing <span class="inlinecode"><span class="id" title="var">ev</span></span> with an <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> declaration tells Coq not
    only that the constructors <span class="inlinecode"><span class="id" title="var">ev_0</span></span> and <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> are valid ways to
    build evidence that some number is <span class="inlinecode"><span class="id" title="var">ev</span></span>, but also that these two
    constructors are the <i>only</i> ways to build evidence that numbers
    are <span class="inlinecode"><span class="id" title="var">ev</span></span>. 
<div class="paragraph"> </div>

<a id="lab269"></a><h3 class="section"> </h3>
 In other words, if someone gives us evidence <span class="inlinecode"><span class="id" title="var">E</span></span> for the assertion
    <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, then we know that <span class="inlinecode"><span class="id" title="var">E</span></span> must be one of two things:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">E</span></span> is <span class="inlinecode"><span class="id" title="var">ev_0</span></span> (and <span class="inlinecode"><span class="id" title="var">n</span></span> is <span class="inlinecode"><span class="id" title="var">O</span></span>), or

</li>
<li> <span class="inlinecode"><span class="id" title="var">E</span></span> is <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode"><span class="id" title="var">E'</span></span> (and <span class="inlinecode"><span class="id" title="var">n</span></span> is <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n'</span>)</span>, where <span class="inlinecode"><span class="id" title="var">E'</span></span> is
        evidence for <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span>). 
</li>
</ul>

<div class="paragraph"> </div>

 This suggests that it should be possible to do <i>case
    analysis</i> and even <i>induction</i> on evidence of evenness... 
<div class="paragraph"> </div>

<a id="lab270"></a><h2 class="section">Inversion on Evidence</h2>

<div class="paragraph"> </div>

 We can prove our characterization of evidence for <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>,
    using <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ev_inversion</span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ev</span> <span class="id" title="var">n</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> = 0) ∨ (<span class="id" title="tactic">∃</span> <span class="id" title="var">n'</span>, <span class="id" title="var">n</span> = <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) ∧ <span class="id" title="var">ev</span> <span class="id" title="var">n'</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> [ | <span class="id" title="var">n'</span> <span class="id" title="var">E'</span>] <span class="id" title="var">eqn</span>:<span class="id" title="var">EE</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;:&nbsp;ev&nbsp;0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'&nbsp;:&nbsp;ev&nbsp;(S&nbsp;(S&nbsp;n'))&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">∃</span> <span class="id" title="var">n'</span>. <span class="id" title="tactic">split</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">E'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Facts like this are often called "inversion lemmas" because they
    allow us to "invert" some given information to reason about all
    the different ways it could have been derived.

<div class="paragraph"> </div>

    Here, there are two ways to prove <span class="inlinecode"><span class="id" title="var">ev</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, and the inversion lemma
    makes this explicit. 
</div>
<div class="quiz">


<div class="doc">
Which tactics are needed to prove this goal?
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">n</span> : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;<span class="id" title="var">E</span> : <span class="id" title="var">ev</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;<span class="id" title="var">F</span> : <span class="id" title="var">n</span> = 1<br/>
&nbsp;&nbsp;======================<br/>
&nbsp;&nbsp;<span class="id" title="var">true</span> = <span class="id" title="var">false</span>
</span>
<div class="paragraph"> </div>

   (1) <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>

<div class="paragraph"> </div>

   (2) <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span>

<div class="paragraph"> </div>

   (3) both <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span>

<div class="paragraph"> </div>

   (4) These tactics are not sufficient to solve the goal. 
</div>
<div class="code">
<div class="togglescript" id="proofcontrol1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')"><span class="show"></span></div>
<div class="proofscript" id="proof1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">quiz_1_not_ev</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">n</span> = 1 → <span class="id" title="var">true</span> = <span class="id" title="var">false</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span> <span class="id" title="var">F</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span> <span class="id" title="var">E'</span>] <span class="id" title="var">eqn</span>:<span class="id" title="var">EE</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">discriminate</span> <span class="id" title="var">F</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">discriminate</span> <span class="id" title="var">F</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div></div> <!-- /quiz -->

<div class="doc">
<a id="lab271"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 We can use the inversion lemma that we proved above to help
    structure proofs: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">evSS_ev</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) → <span class="id" title="var">ev</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">ev_inversion</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">H<sub>0</sub></span>|<span class="id" title="var">H<sub>1</sub></span>].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">discriminate</span> <span class="id" title="var">H<sub>0</sub></span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">H<sub>1</sub></span> <span class="id" title="keyword">as</span> [<span class="id" title="var">n'</span> [<span class="id" title="var">Hnm</span> <span class="id" title="var">Hev</span>]]. <span class="id" title="tactic">injection</span> <span class="id" title="var">Hnm</span> <span class="id" title="keyword">as</span> <span class="id" title="var">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Heq</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">Hev</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab272"></a><h3 class="section"> </h3>
 Coq provides a handy tactic called <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> that does
    the work of our inversion lemma and more besides. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">evSS_ev'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">ev</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) → <span class="id" title="var">ev</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n'</span> <span class="id" title="var">E'</span> <span class="id" title="var">Heq</span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;We&nbsp;are&nbsp;in&nbsp;the&nbsp;<span class="inlinecode"><span class="id" title="var">E</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> <span class="inlinecode"><span class="id" title="var">n'</span></span> <span class="inlinecode"><span class="id" title="var">E'</span></span>&nbsp;case&nbsp;now.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">E'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab273"></a><h3 class="section"> </h3>
 We can use <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> to re-prove some theorems from
    <span class="inlinecode"><span class="id" title="var">Tactics.v</span></span>.  (Note that <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> also works on equality
    propositions.) 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">inversion_ex<sub>1</sub></span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;[<span class="id" title="var">n</span>; <span class="id" title="var">m</span>] = [<span class="id" title="var">o</span>; <span class="id" title="var">o</span>] → [<span class="id" title="var">n</span>] = [<span class="id" title="var">m</span>].<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">o</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">inversion_ex<sub>2</sub></span> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">S</span> <span class="id" title="var">n</span> = <span class="id" title="var">O</span> → 2 + 2 = 5.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">contra</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">contra</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab274"></a><h3 class="section"> </h3>
 The tactic <span class="inlinecode"><span class="id" title="tactic">inversion</span></span> actually works on any <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> where
    <span class="inlinecode"><span class="id" title="var">P</span></span> is defined <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>ly:

<div class="paragraph"> </div>

<ul class="doclist">
<li> For each constructor of <span class="inlinecode"><span class="id" title="var">P</span></span>, make a subgoal where <span class="inlinecode"><span class="id" title="var">H</span></span> is
        constrained by the form of this constructor.

<div class="paragraph"> </div>


</li>
<li> Discard contradictory subgoals (such as <span class="inlinecode"><span class="id" title="var">ev_0</span></span> above).

<div class="paragraph"> </div>


</li>
<li> Generate auxiliary equalities (as with <span class="inlinecode"><span class="id" title="var">ev_SS</span></span> above). 

</li>
</ul>
</div>
<div class="quiz">


<div class="doc">
Which tactics are needed to prove this goal, in addition to
    <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> and <span class="inlinecode"><span class="id" title="tactic">apply</span></span>?
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">n</span> : <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;<span class="id" title="var">E</span> : <span class="id" title="var">ev</span> (<span class="id" title="var">n</span> + 2)<br/>
&nbsp;&nbsp;=====================<br/>
&nbsp;&nbsp;<span class="id" title="var">ev</span> <span class="id" title="var">n</span>
</span>
<div class="paragraph"> </div>

   (1) <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>

<div class="paragraph"> </div>

   (2) <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span>

<div class="paragraph"> </div>

   (3) <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">add_comm</span></span>

<div class="paragraph"> </div>

   (4) <span class="inlinecode"><span class="id" title="tactic">inversion</span></span>, <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">add_comm</span></span>, <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span>

<div class="paragraph"> </div>

   (5) These tactics are not sufficient to prove the goal.

<div class="paragraph"> </div>

 
</div>
<div class="code">
<div class="togglescript" id="proofcontrol2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')"><span class="show"></span></div>
<div class="proofscript" id="proof2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">quiz_ev_plus_2</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">ev</span> (<span class="id" title="var">n</span> + 2) → <span class="id" title="var">ev</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">add_comm</span> <span class="id" title="keyword">in</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">E</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H<sub>0</sub></span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div></div> <!-- /quiz -->

<div class="doc">
<a id="lab275"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 Let's try to show that our new notion of evenness implies
    our earlier notion (the one based on <span class="inlinecode"><span class="id" title="var">double</span></span>). 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ev_Even_firsttry</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">Even</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a id="lab276"></a><h2 class="section">Induction on Evidence</h2>

<div class="paragraph"> </div>

 If this story feels familiar, it is no coincidence: We've
    encountered similar problems in the <a href="Induction.html"><span class="inlineref">Induction</span></a> chapter, when
    trying to use case analysis to prove results that required
    induction.  And once again the solution is... induction! 
<div class="paragraph"> </div>

 Let's try proving that lemma again: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">ev_Even</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">ev</span> <span class="id" title="var">n</span> → <span class="id" title="var">Even</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">n'</span> <span class="id" title="var">E'</span> <span class="id" title="var">IH</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">Even</span>. <span class="id" title="tactic">∃</span> 0. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;IH&nbsp;:&nbsp;Even&nbsp;n'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">Even</span> <span class="id" title="keyword">in</span> <span class="id" title="var">IH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">IH</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">k</span> <span class="id" title="var">Hk</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hk</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">Even</span>. <span class="id" title="tactic">∃</span> (<span class="id" title="var">S</span> <span class="id" title="var">k</span>). <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
As we will see in later chapters, induction on evidence is a
    recurring technique across many areas -- in particular for
    formalizing the semantics of programming languages. 
</div>

<div class="doc">
<a id="lab277"></a><h1 class="section">Inductive Relations</h1>

<div class="paragraph"> </div>

 Just as a single-argument proposition defines a <i>property</i>,
    a two-argument proposition defines a <i>relation</i>. 
</div>

<div class="doc">
Just like properties, relations can be defined inductively.  One
    useful example is the "less than or equal to" relation on numbers
    that we briefly saw above. 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">le</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">le_n</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)                : <span class="id" title="var">le</span> <span class="id" title="var">n</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">le_S</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">le</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) : <span class="id" title="var">le</span> <span class="id" title="var">n</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> &quot;n &lt;= m" := (<span class="id" title="var">le</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>
</div>

<div class="doc">
<a id="lab278"></a><h3 class="section"> </h3>
 Some sanity checks... 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">test_le<sub>1</sub></span> :<br/>
&nbsp;&nbsp;3 ≤ 3.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">test_le<sub>2</sub></span> :<br/>
&nbsp;&nbsp;3 ≤ 6.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">test_le<sub>3</sub></span> :<br/>
&nbsp;&nbsp;(2 ≤ 1) → 2 + 2 = 5.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a id="lab279"></a><h3 class="section"> </h3>
 The "strictly less than" relation <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">m</span></span> can now be defined
    in terms of <span class="inlinecode"><span class="id" title="var">le</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <span class="id" title="var">lt</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) := <span class="id" title="var">le</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="var">m</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Notation</span> &quot;m &lt; n" := (<span class="id" title="var">lt</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>).<br/><hr class='doublespaceincode'/>
</div>

<div class="doc">
<a id="lab280"></a><h3 class="section"> </h3>

</div>

<div class="doc">
<a id="lab281"></a><h1 class="section">A Digression on Notation</h1>

<div class="paragraph"> </div>

 There are several equivalent ways of writing inductive
    types.  We've mostly seen this style... 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <span class="id" title="var">bin1</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">bin</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">Z</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">B<sub>0</sub></span> (<span class="id" title="var">n</span> : <span class="id" title="var">bin</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">B<sub>1</sub></span> (<span class="id" title="var">n</span> : <span class="id" title="var">bin</span>).<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">bin1</span>.<br/>
</div>

<div class="doc">
... which omits the result types because they are all bin. 
<div class="paragraph"> </div>

 It is completely equivalent to this... 
</div>
<div class="code">
<span class="id" title="keyword">Module</span> <span class="id" title="var">bin2</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">bin</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">Z</span> : <span class="id" title="var">bin</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">B<sub>0</sub></span> (<span class="id" title="var">n</span> : <span class="id" title="var">bin</span>) : <span class="id" title="var">bin</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">B<sub>1</sub></span> (<span class="id" title="var">n</span> : <span class="id" title="var">bin</span>) : <span class="id" title="var">bin</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">bin2</span>.<br/>
</div>

<div class="doc">
... where we fill them in, and this... 
</div>
<div class="code">

<span class="id" title="keyword">Module</span> <span class="id" title="var">bin3</span>.<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">bin</span> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">Z</span> : <span class="id" title="var">bin</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">B<sub>0</sub></span> : <span class="id" title="var">bin</span> → <span class="id" title="var">bin</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">B<sub>1</sub></span> : <span class="id" title="var">bin</span> → <span class="id" title="var">bin</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">bin3</span>.<br/>
</div>

<div class="doc">
... where we put everything on the right of the colon. 
<div class="paragraph"> </div>

 For inductively defined <i>propositions</i>, we need to explicitly give
    the result type for each constructor (because they are not all the
    same), so the first style doesn't make sense, but we can use
    either the second or the third interchangeably. 
</div>

<div class="doc">
<a id="lab282"></a><h1 class="section">Case Study: Regular Expressions</h1>

<div class="paragraph"> </div>

 Regular expressions are a simple language for describing sets of
    strings.  Their syntax is defined as follows: 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">reg_exp</span> (<span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">EmptySet</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">EmptyStr</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Char</span> (<span class="id" title="var">t</span> : <span class="id" title="var">T</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">App</span> (<span class="id" title="var">r<sub>1</sub></span> <span class="id" title="var">r<sub>2</sub></span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">Union</span> (<span class="id" title="var">r<sub>1</sub></span> <span class="id" title="var">r<sub>2</sub></span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">Star</span> (<span class="id" title="var">r</span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>).<br/><hr class='doublespaceincode'/>
</div>

<div class="doc">
<a id="lab283"></a><h3 class="section"> </h3>
 We connect regular expressions and strings via the following
    rules, which define when a regular expression <i>matches</i> some
    string:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The expression <span class="inlinecode"><span class="id" title="var">EmptySet</span></span> does not match any string.

<div class="paragraph"> </div>


</li>
<li> The expression <span class="inlinecode"><span class="id" title="var">EmptyStr</span></span> matches the empty string <span class="inlinecode">[]</span>.

<div class="paragraph"> </div>


</li>
<li> The expression <span class="inlinecode"><span class="id" title="var">Char</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> matches the one-character string <span class="inlinecode">[<span class="id" title="var">x</span>]</span>.

<div class="paragraph"> </div>


</li>
<li> If <span class="inlinecode"><span class="id" title="var">re<sub>1</sub></span></span> matches <span class="inlinecode"><span class="id" title="var">s<sub>1</sub></span></span>, and <span class="inlinecode"><span class="id" title="var">re<sub>2</sub></span></span> matches <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span>,
        then <span class="inlinecode"><span class="id" title="var">App</span></span> <span class="inlinecode"><span class="id" title="var">re<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">re<sub>2</sub></span></span> matches <span class="inlinecode"><span class="id" title="var">s<sub>1</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span>.

<div class="paragraph"> </div>


</li>
<li> If at least one of <span class="inlinecode"><span class="id" title="var">re<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">re<sub>2</sub></span></span> matches <span class="inlinecode"><span class="id" title="var">s</span></span>,
        then <span class="inlinecode"><span class="id" title="var">Union</span></span> <span class="inlinecode"><span class="id" title="var">re<sub>1</sub></span></span> <span class="inlinecode"><span class="id" title="var">re<sub>2</sub></span></span> matches <span class="inlinecode"><span class="id" title="var">s</span></span>.

<div class="paragraph"> </div>


</li>
<li> Finally, if we can write some string <span class="inlinecode"><span class="id" title="var">s</span></span> as the concatenation
        of a sequence of strings <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">s_1</span></span> <span class="inlinecode">++</span> <span class="inlinecode">...</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">s_k</span></span>, and the
        expression <span class="inlinecode"><span class="id" title="var">re</span></span> matches each one of the strings <span class="inlinecode"><span class="id" title="var">s_i</span></span>,
        then <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span> matches <span class="inlinecode"><span class="id" title="var">s</span></span>.

<div class="paragraph"> </div>

        In particular, the sequence of strings may be empty, so
        <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span> always matches the empty string <span class="inlinecode">[]</span> no matter what
        <span class="inlinecode"><span class="id" title="var">re</span></span> is. 
</li>
</ul>

<div class="paragraph"> </div>

<a id="lab284"></a><h3 class="section"> </h3>
 We can easily translate this informal definition into an
    <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> one as follows.  We use the notation <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" title="var">re</span></span> in
    place of <span class="inlinecode"><span class="id" title="var">exp_match</span></span> <span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>.  (By "reserving" the notation before
    defining the <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>, we can use it in the definition.) 
</div>
<div class="code">

<span class="id" title="keyword">Reserved Notation</span> &quot;s =~ re" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 80).<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">exp_match</span> {<span class="id" title="var">T</span>} : <span class="id" title="var">list</span> <span class="id" title="var">T</span> → <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">MEmpty</span> : [] =~ <span class="id" title="var">EmptyStr</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">MChar</span> <span class="id" title="var">x</span> : [<span class="id" title="var">x</span>] =~ (<span class="id" title="var">Char</span> <span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">MApp</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H<sub>1</sub></span> : <span class="id" title="var">s<sub>1</sub></span> =~ <span class="id" title="var">re<sub>1</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H<sub>2</sub></span> : <span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">re<sub>2</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: (<span class="id" title="var">s<sub>1</sub></span> ++ <span class="id" title="var">s<sub>2</sub></span>) =~ (<span class="id" title="var">App</span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">re<sub>2</sub></span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">MUnionL</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H<sub>1</sub></span> : <span class="id" title="var">s<sub>1</sub></span> =~ <span class="id" title="var">re<sub>1</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">s<sub>1</sub></span> =~ (<span class="id" title="var">Union</span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">re<sub>2</sub></span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">MUnionR</span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H<sub>2</sub></span> : <span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">re<sub>2</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">s<sub>2</sub></span> =~ (<span class="id" title="var">Union</span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">re<sub>2</sub></span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">MStar0</span> <span class="id" title="var">re</span> : [] =~ (<span class="id" title="var">Star</span> <span class="id" title="var">re</span>)<br/>
&nbsp;&nbsp;| <span class="id" title="var">MStarApp</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">re</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H<sub>1</sub></span> : <span class="id" title="var">s<sub>1</sub></span> =~ <span class="id" title="var">re</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">H<sub>2</sub></span> : <span class="id" title="var">s<sub>2</sub></span> =~ (<span class="id" title="var">Star</span> <span class="id" title="var">re</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: (<span class="id" title="var">s<sub>1</sub></span> ++ <span class="id" title="var">s<sub>2</sub></span>) =~ (<span class="id" title="var">Star</span> <span class="id" title="var">re</span>)<br/>
<br/>
&nbsp;&nbsp;<span class="id" title="keyword">where</span> &quot;s =~ re" := (<span class="id" title="var">exp_match</span> <span class="id" title="var">s</span> <span class="id" title="var">re</span>).<br/><hr class='doublespaceincode'/>
 <!-- /quiz -->
</div><div class="quiz">


<div class="doc">
Notice that this clause in our informal definition...

<div class="paragraph"> </div>

<ul class="doclist">
<li> "The expression <span class="inlinecode"><span class="id" title="var">EmptySet</span></span> does not match any string."

</li>
</ul>

<div class="paragraph"> </div>

    ... is not explicitly reflected in the above definition.  Do we
    need to add something?

<div class="paragraph"> </div>

   (1) Yes, we should add a rule for this.

<div class="paragraph"> </div>

   (2) No, one of the other rules already covers this case.

<div class="paragraph"> </div>

   (3) No, the <i>lack</i> of a rule actually gives us the behavior we
       want.

<div class="paragraph"> </div>


</div>
</div> <!-- /quiz -->

<div class="doc">
<a id="lab285"></a><h3 class="section"> </h3>

</div>
<div class="code">
<span class="id" title="keyword">Example</span> <span class="id" title="var">reg_exp_ex<sub>1</sub></span> : [1] =~ <span class="id" title="var">Char</span> 1.<br/>
<div class="togglescript" id="proofcontrol3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')"><span class="show"></span></div>
<div class="proofscript" id="proof3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">MChar</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">reg_exp_ex<sub>2</sub></span> : [1; 2] =~ <span class="id" title="var">App</span> (<span class="id" title="var">Char</span> 1) (<span class="id" title="var">Char</span> 2).<br/>
<div class="togglescript" id="proofcontrol4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')"><span class="show"></span></div>
<div class="proofscript" id="proof4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">MApp</span> [1]).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">MChar</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">MChar</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">reg_exp_ex<sub>3</sub></span> : ¬([1; 2] =~ <span class="id" title="var">Char</span> 1).<br/>
<div class="togglescript" id="proofcontrol5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')"><span class="show"></span></div>
<div class="proofscript" id="proof5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')">
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
<a id="lab286"></a><h3 class="section"> </h3>
 Something more interesting: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">MStar1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">T</span> <span class="id" title="var">s</span> (<span class="id" title="var">re</span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>) ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">s</span> =~ <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">s</span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span>.<br/>
<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a id="lab287"></a><h2 class="section">The <span class="inlinecode"><span class="id" title="var">remember</span></span> Tactic</h2>

<div class="paragraph"> </div>

 One potentially confusing feature of the <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic is
    that it will let you try to perform an induction over a term that
    isn't sufficiently general.  The effect of this is to lose
    information (much as <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> without an <span class="inlinecode"><span class="id" title="var">eqn</span>:</span> clause can do),
    and leave you unable to complete the proof.  Here's an example: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">star_app</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">T</span> (<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span>) (<span class="id" title="var">re</span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> ++ <span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">T</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">re</span> <span class="id" title="var">H<sub>1</sub></span>.<br/>
</div>

<div class="doc">
A naive first attempt at setting up the induction.  (Note
    that we are performing induction on evidence!)  (We can begin by generalizing <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span>, since it's pretty clear that we
    are going to have to walk over both <span class="inlinecode"><span class="id" title="var">s<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" title="var">s<sub>2</sub></span></span> in parallel.) 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">s<sub>2</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H<sub>1</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">as</span> [|<span class="id" title="var">x'</span>|<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">re<sub>2</sub></span> <span class="id" title="var">Hmatch1</span> <span class="id" title="var">IH<sub>1</sub></span> <span class="id" title="var">Hmatch2</span> <span class="id" title="var">IH<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">re<sub>2</sub></span> <span class="id" title="var">Hmatch</span> <span class="id" title="var">IH</span>|<span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">re<sub>2</sub></span> <span class="id" title="var">Hmatch</span> <span class="id" title="var">IH</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" title="var">re''</span>|<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">re''</span> <span class="id" title="var">Hmatch1</span> <span class="id" title="var">IH<sub>1</sub></span> <span class="id" title="var">Hmatch2</span> <span class="id" title="var">IH<sub>2</sub></span>].<br/>
</div>

<div class="doc">
<a id="lab288"></a><h3 class="section"> </h3>
 We can get through the first case... 
</div>
<div class="code">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MEmpty&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
</div>

<div class="doc">
... but most cases get stuck.  For <span class="inlinecode"><span class="id" title="var">MChar</span></span>, for instance, we
    must show
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">s<sub>2</sub></span>     =~ <span class="id" title="var">Char</span> <span class="id" title="var">x'</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">x'</span>::<span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Char</span> <span class="id" title="var">x'</span>
</span>    which is clearly impossible. 
</div>
<div class="code">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MChar.&nbsp;*)</span> <span class="id" title="tactic">intros</span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">H</span>. <span class="id" title="tactic">simpl</span>. <span class="comment">(*&nbsp;Stuck...&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
<a id="lab289"></a><h3 class="section"> </h3>
 The problem here is that <span class="inlinecode"><span class="id" title="tactic">induction</span></span> over a Prop hypothesis
    only works properly with hypotheses that are "completely
    general," i.e., ones in which all the arguments are variables,
    as opposed to more complex expressions like <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>.

<div class="paragraph"> </div>

    A possible, but awkward, way to solve this problem is "manually
    generalizing" over the problematic expressions by adding
    explicit equality hypotheses to the lemma: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">star_app</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">T</span> (<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span>) (<span class="id" title="var">re</span> <span class="id" title="var">re'</span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">re'</span> = <span class="id" title="var">Star</span> <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> =~ <span class="id" title="var">re'</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> ++ <span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span>.<br/>
</div>

<div class="doc">
This works, but it makes the statement of the lemma a bit ugly.
    Fortunately, there is a better way... 
</div>
<div class="code">
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
<a id="lab290"></a><h3 class="section"> </h3>
 The tactic <span class="inlinecode"><span class="id" title="var">remember</span></span> <span class="inlinecode"><span class="id" title="var">e</span></span> <span class="inlinecode"><span class="id" title="keyword">as</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> causes Coq to (1) replace all
    occurrences of the expression <span class="inlinecode"><span class="id" title="var">e</span></span> by the variable <span class="inlinecode"><span class="id" title="var">x</span></span>, and (2) add
    an equation <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">e</span></span> to the context.  Here's how we can use it to
    show the above result: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">star_app</span>: <span class="id" title="keyword">∀</span> <span class="id" title="var">T</span> (<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span>) (<span class="id" title="var">re</span> : <span class="id" title="var">reg_exp</span> <span class="id" title="var">T</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span> →<br/>
&nbsp;&nbsp;<span class="id" title="var">s<sub>1</sub></span> ++ <span class="id" title="var">s<sub>2</sub></span> =~ <span class="id" title="var">Star</span> <span class="id" title="var">re</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">T</span> <span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">re</span> <span class="id" title="var">H<sub>1</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">Star</span> <span class="id" title="var">re</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">re'</span>.<br/>
</div>

<div class="doc">
We now have <span class="inlinecode"><span class="id" title="var">Heqre'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">re'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>. 
</div>
<div class="code">

&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">s<sub>2</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">H<sub>1</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">as</span> [|<span class="id" title="var">x'</span>|<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">re<sub>2</sub></span> <span class="id" title="var">Hmatch1</span> <span class="id" title="var">IH<sub>1</sub></span> <span class="id" title="var">Hmatch2</span> <span class="id" title="var">IH<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">re<sub>2</sub></span> <span class="id" title="var">Hmatch</span> <span class="id" title="var">IH</span>|<span class="id" title="var">re<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">re<sub>2</sub></span> <span class="id" title="var">Hmatch</span> <span class="id" title="var">IH</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" title="var">re''</span>|<span class="id" title="var">s<sub>1</sub></span> <span class="id" title="var">s<sub>2</sub>'</span> <span class="id" title="var">re''</span> <span class="id" title="var">Hmatch1</span> <span class="id" title="var">IH<sub>1</sub></span> <span class="id" title="var">Hmatch2</span> <span class="id" title="var">IH<sub>2</sub></span>].<br/>
</div>

<div class="doc">
<a id="lab291"></a><h3 class="section"> </h3>
 The <span class="inlinecode"><span class="id" title="var">Heqre'</span></span> is contradictory in most cases, allowing us to
    conclude immediately. 
</div>
<div class="code">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MEmpty&nbsp;*)</span>  <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MChar&nbsp;*)</span>   <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MApp&nbsp;*)</span>    <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MUnionL&nbsp;*)</span> <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MUnionR&nbsp;*)</span> <span class="id" title="tactic">discriminate</span>.<br/>
</div>

<div class="doc">
The interesting cases are those that correspond to <span class="inlinecode"><span class="id" title="var">Star</span></span>.  Note
    that the induction hypothesis <span class="inlinecode"><span class="id" title="var">IH<sub>2</sub></span></span> on the <span class="inlinecode"><span class="id" title="var">MStarApp</span></span> case
    mentions an additional premise <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re''</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">Star</span></span> <span class="inlinecode"><span class="id" title="var">re</span></span>, which
    results from the equality generated by <span class="inlinecode"><span class="id" title="var">remember</span></span>. 
</div>
<div class="code">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MStar0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">injection</span> <span class="id" title="var">Heqre'</span> <span class="id" title="keyword">as</span> <span class="id" title="var">Heqre''</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">s</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MStarApp&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">injection</span> <span class="id" title="var">Heqre'</span> <span class="id" title="keyword">as</span> <span class="id" title="var">Heqre''</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">s<sub>2</sub></span> <span class="id" title="var">H<sub>1</sub></span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">app_assoc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">MStarApp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">Hmatch1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">IH<sub>2</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Heqre''</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">apply</span> <span class="id" title="var">H<sub>1</sub></span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab292"></a><h1 class="section">Case Study: Improving Reflection</h1>

<div class="paragraph"> </div>

 We've seen that we often need to relate boolean
    computations to statements in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.  However, this can
    result in some tedium in proof scripts.

<div class="paragraph"> </div>

    Consider: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">filter_not_empty_In</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">filter</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">n</span> =? <span class="id" title="var">x</span>) <span class="id" title="var">l</span> ≠ [] →<br/>
&nbsp;&nbsp;<span class="id" title="var">In</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">m</span> <span class="id" title="var">l'</span> <span class="id" title="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;<span class="inlinecode"></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">n</span> =? <span class="id" title="var">m</span>) <span class="id" title="var">eqn</span>:<span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;=?&nbsp;m&nbsp;=&nbsp;true&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">_</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">eqb_eq</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;=?&nbsp;m&nbsp;=&nbsp;false&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHl'</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The first subcase (where <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>) is awkward
    because we have to explicitly "switch worlds."

<div class="paragraph"> </div>

    It would be annoying to have to do this kind of thing all the
    time. 
<div class="paragraph"> </div>

<a id="lab293"></a><h3 class="section"> </h3>
 We can streamline this sort of reasoning by defining an inductive
    proposition that yields a better case-analysis principle for <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span>
    <span class="inlinecode"><span class="id" title="var">m</span></span>.  Instead of generating the assumption <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span>, which
    usually requires some massaging before we can use it, this
    principle gives us right away the assumption we really need: <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" title="var">m</span></span>.

<div class="paragraph"> </div>

    Following the terminology introduced in <a href="Logic.html"><span class="inlineref">Logic</span></a>, we call this
    the "reflection principle for equality on numbers," and we say
    that the boolean <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=?</span> <span class="inlinecode"><span class="id" title="var">m</span></span> is <i>reflected in</i> the proposition <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Inductive</span> <span class="id" title="var">reflect</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="var">bool</span> → <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">ReflectT</span> (<span class="id" title="var">H</span> :   <span class="id" title="var">P</span>) : <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">ReflectF</span> (<span class="id" title="var">H</span> : ¬<span class="id" title="var">P</span>) : <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> <span class="id" title="var">false</span>.<br/>
</div>

<div class="doc">
Notice that the only way to produce evidence for <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span>
    <span class="inlinecode"><span class="id" title="var">true</span></span> is by showing <span class="inlinecode"><span class="id" title="var">P</span></span> and then using the <span class="inlinecode"><span class="id" title="var">ReflectT</span></span> constructor.

<div class="paragraph"> </div>

    If we play this reasoning backwards, it says we can extract
    <i>evidence</i> for <span class="inlinecode"><span class="id" title="var">P</span></span> from evidence for <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span>. 
<div class="paragraph"> </div>

 To put this observation to work, we first prove that the
    statements <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">↔</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">true</span></span> and <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> are indeed
    equivalent.  First, the left-to-right implication: 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">iff_reflect</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">b</span>, (<span class="id" title="var">P</span> ↔ <span class="id" title="var">b</span> = <span class="id" title="var">true</span>) → <span class="id" title="var">reflect</span> <span class="id" title="var">P</span> <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;WORK&nbsp;IN&nbsp;CLASS&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
(The right-to-left implication is left as an exercise.) 
<div class="paragraph"> </div>

<a id="lab294"></a><h3 class="section"> </h3>
 We can think of <span class="inlinecode"><span class="id" title="var">reflect</span></span> as a kind of variant of the usual "if
    and only if" connective; the advantage of <span class="inlinecode"><span class="id" title="var">reflect</span></span> is that, by
    destructing a hypothesis or lemma of the form <span class="inlinecode"><span class="id" title="var">reflect</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>, we
    can perform case analysis on <span class="inlinecode"><span class="id" title="var">b</span></span> while <i>at the same time</i>
    generating appropriate hypothesis in the two branches (<span class="inlinecode"><span class="id" title="var">P</span></span> in the
    first subgoal and <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" title="var">P</span></span> in the second). 
<div class="paragraph"> </div>

<a id="lab295"></a><h3 class="section"> </h3>
 Let's use <span class="inlinecode"><span class="id" title="var">reflect</span></span> to produce a smoother proof of
    <span class="inlinecode"><span class="id" title="var">filter_not_empty_In</span></span>.

<div class="paragraph"> </div>

    We begin by recasting the <span class="inlinecode"><span class="id" title="var">eqb_eq</span></span> lemma in terms of <span class="inlinecode"><span class="id" title="var">reflect</span></span>: 
</div>
<div class="code">

<span class="id" title="keyword">Lemma</span> <span class="id" title="var">eqbP</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, <span class="id" title="var">reflect</span> (<span class="id" title="var">n</span> = <span class="id" title="var">m</span>) (<span class="id" title="var">n</span> =? <span class="id" title="var">m</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">iff_reflect</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">eqb_eq</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab296"></a><h3 class="section"> </h3>
 The proof of <span class="inlinecode"><span class="id" title="var">filter_not_empty_In</span></span> now goes as follows.  Notice
    how the calls to <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> in the earlier proof of
    this theorem are combined here into a single call to
    <span class="inlinecode"><span class="id" title="tactic">destruct</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <span class="id" title="var">filter_not_empty_In'</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">filter</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">n</span> =? <span class="id" title="var">x</span>) <span class="id" title="var">l</span> ≠ [] →<br/>
&nbsp;&nbsp;<span class="id" title="var">In</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">induction</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">m</span> <span class="id" title="var">l'</span> <span class="id" title="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;<span class="inlinecode"></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">eqbP</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">H</span> | <span class="id" title="var">H</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;=&nbsp;m&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">_</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;&lt;&gt;&nbsp;m&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H'</span>. <span class="id" title="tactic">right</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHl'</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H'</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a id="lab297"></a><h3 class="section"> </h3>
 This small example shows reflection giving us a small gain in
    convenience; in larger developments, using <span class="inlinecode"><span class="id" title="var">reflect</span></span> consistently
    can often lead to noticeably shorter and clearer proof scripts.
    We'll see many more examples in later chapters and in <i>Programming
    Language Foundations</i>.

<div class="paragraph"> </div>

    This use of <span class="inlinecode"><span class="id" title="var">reflect</span></span> was popularized by <i>SSReflect</i>, a Coq
    library that has been used to formalize important results in
    mathematics, including the 4-color theorem and the Feit-Thompson
    theorem.  The name SSReflect stands for <i>small-scale reflection</i>,
    i.e., the pervasive use of reflection to simplify small proof
    steps by turning them into boolean computations. 
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>